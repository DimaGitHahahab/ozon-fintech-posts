// Code generated by http://github.com/gojuno/minimock (v3.3.9). DO NOT EDIT.

package resolvers

//go:generate minimock -i github.com/DimaGitHahahab/ozon-fintech-posts/internal/repository.Repository -o repository_mock_test.go -n RepositoryMock -p resolvers

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/DimaGitHahahab/ozon-fintech-posts/internal/domain"
	"github.com/gojuno/minimock/v3"
)

// RepositoryMock implements repository.Repository
type RepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcContainsComment          func(ctx context.Context, id int) (b1 bool, err error)
	inspectFuncContainsComment   func(ctx context.Context, id int)
	afterContainsCommentCounter  uint64
	beforeContainsCommentCounter uint64
	ContainsCommentMock          mRepositoryMockContainsComment

	funcContainsPost          func(ctx context.Context, id int) (b1 bool, err error)
	inspectFuncContainsPost   func(ctx context.Context, id int)
	afterContainsPostCounter  uint64
	beforeContainsPostCounter uint64
	ContainsPostMock          mRepositoryMockContainsPost

	funcCreateComment          func(ctx context.Context, comment *domain.Comment) (cp1 *domain.Comment, err error)
	inspectFuncCreateComment   func(ctx context.Context, comment *domain.Comment)
	afterCreateCommentCounter  uint64
	beforeCreateCommentCounter uint64
	CreateCommentMock          mRepositoryMockCreateComment

	funcCreatePost          func(ctx context.Context, post *domain.Post) (pp1 *domain.Post, err error)
	inspectFuncCreatePost   func(ctx context.Context, post *domain.Post)
	afterCreatePostCounter  uint64
	beforeCreatePostCounter uint64
	CreatePostMock          mRepositoryMockCreatePost

	funcDisableComments          func(ctx context.Context, postID int) (err error)
	inspectFuncDisableComments   func(ctx context.Context, postID int)
	afterDisableCommentsCounter  uint64
	beforeDisableCommentsCounter uint64
	DisableCommentsMock          mRepositoryMockDisableComments

	funcGetCommentsByParent          func(ctx context.Context, parentId int, limit int, offset int) (cpa1 []*domain.Comment, err error)
	inspectFuncGetCommentsByParent   func(ctx context.Context, parentId int, limit int, offset int)
	afterGetCommentsByParentCounter  uint64
	beforeGetCommentsByParentCounter uint64
	GetCommentsByParentMock          mRepositoryMockGetCommentsByParent

	funcGetCommentsByPost          func(ctx context.Context, postID int, limit int, offset int) (cpa1 []*domain.Comment, err error)
	inspectFuncGetCommentsByPost   func(ctx context.Context, postID int, limit int, offset int)
	afterGetCommentsByPostCounter  uint64
	beforeGetCommentsByPostCounter uint64
	GetCommentsByPostMock          mRepositoryMockGetCommentsByPost

	funcGetPost          func(ctx context.Context, id int) (pp1 *domain.Post, err error)
	inspectFuncGetPost   func(ctx context.Context, id int)
	afterGetPostCounter  uint64
	beforeGetPostCounter uint64
	GetPostMock          mRepositoryMockGetPost

	funcGetPosts          func(ctx context.Context) (ppa1 []*domain.Post, err error)
	inspectFuncGetPosts   func(ctx context.Context)
	afterGetPostsCounter  uint64
	beforeGetPostsCounter uint64
	GetPostsMock          mRepositoryMockGetPosts
}

// NewRepositoryMock returns a mock for repository.Repository
func NewRepositoryMock(t minimock.Tester) *RepositoryMock {
	m := &RepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.ContainsCommentMock = mRepositoryMockContainsComment{mock: m}
	m.ContainsCommentMock.callArgs = []*RepositoryMockContainsCommentParams{}

	m.ContainsPostMock = mRepositoryMockContainsPost{mock: m}
	m.ContainsPostMock.callArgs = []*RepositoryMockContainsPostParams{}

	m.CreateCommentMock = mRepositoryMockCreateComment{mock: m}
	m.CreateCommentMock.callArgs = []*RepositoryMockCreateCommentParams{}

	m.CreatePostMock = mRepositoryMockCreatePost{mock: m}
	m.CreatePostMock.callArgs = []*RepositoryMockCreatePostParams{}

	m.DisableCommentsMock = mRepositoryMockDisableComments{mock: m}
	m.DisableCommentsMock.callArgs = []*RepositoryMockDisableCommentsParams{}

	m.GetCommentsByParentMock = mRepositoryMockGetCommentsByParent{mock: m}
	m.GetCommentsByParentMock.callArgs = []*RepositoryMockGetCommentsByParentParams{}

	m.GetCommentsByPostMock = mRepositoryMockGetCommentsByPost{mock: m}
	m.GetCommentsByPostMock.callArgs = []*RepositoryMockGetCommentsByPostParams{}

	m.GetPostMock = mRepositoryMockGetPost{mock: m}
	m.GetPostMock.callArgs = []*RepositoryMockGetPostParams{}

	m.GetPostsMock = mRepositoryMockGetPosts{mock: m}
	m.GetPostsMock.callArgs = []*RepositoryMockGetPostsParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mRepositoryMockContainsComment struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockContainsCommentExpectation
	expectations       []*RepositoryMockContainsCommentExpectation

	callArgs []*RepositoryMockContainsCommentParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryMockContainsCommentExpectation specifies expectation struct of the Repository.ContainsComment
type RepositoryMockContainsCommentExpectation struct {
	mock      *RepositoryMock
	params    *RepositoryMockContainsCommentParams
	paramPtrs *RepositoryMockContainsCommentParamPtrs
	results   *RepositoryMockContainsCommentResults
	Counter   uint64
}

// RepositoryMockContainsCommentParams contains parameters of the Repository.ContainsComment
type RepositoryMockContainsCommentParams struct {
	ctx context.Context
	id  int
}

// RepositoryMockContainsCommentParamPtrs contains pointers to parameters of the Repository.ContainsComment
type RepositoryMockContainsCommentParamPtrs struct {
	ctx *context.Context
	id  *int
}

// RepositoryMockContainsCommentResults contains results of the Repository.ContainsComment
type RepositoryMockContainsCommentResults struct {
	b1  bool
	err error
}

// Expect sets up expected params for Repository.ContainsComment
func (mmContainsComment *mRepositoryMockContainsComment) Expect(ctx context.Context, id int) *mRepositoryMockContainsComment {
	if mmContainsComment.mock.funcContainsComment != nil {
		mmContainsComment.mock.t.Fatalf("RepositoryMock.ContainsComment mock is already set by Set")
	}

	if mmContainsComment.defaultExpectation == nil {
		mmContainsComment.defaultExpectation = &RepositoryMockContainsCommentExpectation{}
	}

	if mmContainsComment.defaultExpectation.paramPtrs != nil {
		mmContainsComment.mock.t.Fatalf("RepositoryMock.ContainsComment mock is already set by ExpectParams functions")
	}

	mmContainsComment.defaultExpectation.params = &RepositoryMockContainsCommentParams{ctx, id}
	for _, e := range mmContainsComment.expectations {
		if minimock.Equal(e.params, mmContainsComment.defaultExpectation.params) {
			mmContainsComment.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmContainsComment.defaultExpectation.params)
		}
	}

	return mmContainsComment
}

// ExpectCtxParam1 sets up expected param ctx for Repository.ContainsComment
func (mmContainsComment *mRepositoryMockContainsComment) ExpectCtxParam1(ctx context.Context) *mRepositoryMockContainsComment {
	if mmContainsComment.mock.funcContainsComment != nil {
		mmContainsComment.mock.t.Fatalf("RepositoryMock.ContainsComment mock is already set by Set")
	}

	if mmContainsComment.defaultExpectation == nil {
		mmContainsComment.defaultExpectation = &RepositoryMockContainsCommentExpectation{}
	}

	if mmContainsComment.defaultExpectation.params != nil {
		mmContainsComment.mock.t.Fatalf("RepositoryMock.ContainsComment mock is already set by Expect")
	}

	if mmContainsComment.defaultExpectation.paramPtrs == nil {
		mmContainsComment.defaultExpectation.paramPtrs = &RepositoryMockContainsCommentParamPtrs{}
	}
	mmContainsComment.defaultExpectation.paramPtrs.ctx = &ctx

	return mmContainsComment
}

// ExpectIdParam2 sets up expected param id for Repository.ContainsComment
func (mmContainsComment *mRepositoryMockContainsComment) ExpectIdParam2(id int) *mRepositoryMockContainsComment {
	if mmContainsComment.mock.funcContainsComment != nil {
		mmContainsComment.mock.t.Fatalf("RepositoryMock.ContainsComment mock is already set by Set")
	}

	if mmContainsComment.defaultExpectation == nil {
		mmContainsComment.defaultExpectation = &RepositoryMockContainsCommentExpectation{}
	}

	if mmContainsComment.defaultExpectation.params != nil {
		mmContainsComment.mock.t.Fatalf("RepositoryMock.ContainsComment mock is already set by Expect")
	}

	if mmContainsComment.defaultExpectation.paramPtrs == nil {
		mmContainsComment.defaultExpectation.paramPtrs = &RepositoryMockContainsCommentParamPtrs{}
	}
	mmContainsComment.defaultExpectation.paramPtrs.id = &id

	return mmContainsComment
}

// Inspect accepts an inspector function that has same arguments as the Repository.ContainsComment
func (mmContainsComment *mRepositoryMockContainsComment) Inspect(f func(ctx context.Context, id int)) *mRepositoryMockContainsComment {
	if mmContainsComment.mock.inspectFuncContainsComment != nil {
		mmContainsComment.mock.t.Fatalf("Inspect function is already set for RepositoryMock.ContainsComment")
	}

	mmContainsComment.mock.inspectFuncContainsComment = f

	return mmContainsComment
}

// Return sets up results that will be returned by Repository.ContainsComment
func (mmContainsComment *mRepositoryMockContainsComment) Return(b1 bool, err error) *RepositoryMock {
	if mmContainsComment.mock.funcContainsComment != nil {
		mmContainsComment.mock.t.Fatalf("RepositoryMock.ContainsComment mock is already set by Set")
	}

	if mmContainsComment.defaultExpectation == nil {
		mmContainsComment.defaultExpectation = &RepositoryMockContainsCommentExpectation{mock: mmContainsComment.mock}
	}
	mmContainsComment.defaultExpectation.results = &RepositoryMockContainsCommentResults{b1, err}
	return mmContainsComment.mock
}

// Set uses given function f to mock the Repository.ContainsComment method
func (mmContainsComment *mRepositoryMockContainsComment) Set(f func(ctx context.Context, id int) (b1 bool, err error)) *RepositoryMock {
	if mmContainsComment.defaultExpectation != nil {
		mmContainsComment.mock.t.Fatalf("Default expectation is already set for the Repository.ContainsComment method")
	}

	if len(mmContainsComment.expectations) > 0 {
		mmContainsComment.mock.t.Fatalf("Some expectations are already set for the Repository.ContainsComment method")
	}

	mmContainsComment.mock.funcContainsComment = f
	return mmContainsComment.mock
}

// When sets expectation for the Repository.ContainsComment which will trigger the result defined by the following
// Then helper
func (mmContainsComment *mRepositoryMockContainsComment) When(ctx context.Context, id int) *RepositoryMockContainsCommentExpectation {
	if mmContainsComment.mock.funcContainsComment != nil {
		mmContainsComment.mock.t.Fatalf("RepositoryMock.ContainsComment mock is already set by Set")
	}

	expectation := &RepositoryMockContainsCommentExpectation{
		mock:   mmContainsComment.mock,
		params: &RepositoryMockContainsCommentParams{ctx, id},
	}
	mmContainsComment.expectations = append(mmContainsComment.expectations, expectation)
	return expectation
}

// Then sets up Repository.ContainsComment return parameters for the expectation previously defined by the When method
func (e *RepositoryMockContainsCommentExpectation) Then(b1 bool, err error) *RepositoryMock {
	e.results = &RepositoryMockContainsCommentResults{b1, err}
	return e.mock
}

// Times sets number of times Repository.ContainsComment should be invoked
func (mmContainsComment *mRepositoryMockContainsComment) Times(n uint64) *mRepositoryMockContainsComment {
	if n == 0 {
		mmContainsComment.mock.t.Fatalf("Times of RepositoryMock.ContainsComment mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmContainsComment.expectedInvocations, n)
	return mmContainsComment
}

func (mmContainsComment *mRepositoryMockContainsComment) invocationsDone() bool {
	if len(mmContainsComment.expectations) == 0 && mmContainsComment.defaultExpectation == nil && mmContainsComment.mock.funcContainsComment == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmContainsComment.mock.afterContainsCommentCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmContainsComment.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ContainsComment implements repository.Repository
func (mmContainsComment *RepositoryMock) ContainsComment(ctx context.Context, id int) (b1 bool, err error) {
	mm_atomic.AddUint64(&mmContainsComment.beforeContainsCommentCounter, 1)
	defer mm_atomic.AddUint64(&mmContainsComment.afterContainsCommentCounter, 1)

	if mmContainsComment.inspectFuncContainsComment != nil {
		mmContainsComment.inspectFuncContainsComment(ctx, id)
	}

	mm_params := RepositoryMockContainsCommentParams{ctx, id}

	// Record call args
	mmContainsComment.ContainsCommentMock.mutex.Lock()
	mmContainsComment.ContainsCommentMock.callArgs = append(mmContainsComment.ContainsCommentMock.callArgs, &mm_params)
	mmContainsComment.ContainsCommentMock.mutex.Unlock()

	for _, e := range mmContainsComment.ContainsCommentMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1, e.results.err
		}
	}

	if mmContainsComment.ContainsCommentMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmContainsComment.ContainsCommentMock.defaultExpectation.Counter, 1)
		mm_want := mmContainsComment.ContainsCommentMock.defaultExpectation.params
		mm_want_ptrs := mmContainsComment.ContainsCommentMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockContainsCommentParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmContainsComment.t.Errorf("RepositoryMock.ContainsComment got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmContainsComment.t.Errorf("RepositoryMock.ContainsComment got unexpected parameter id, want: %#v, got: %#v%s\n", *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmContainsComment.t.Errorf("RepositoryMock.ContainsComment got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmContainsComment.ContainsCommentMock.defaultExpectation.results
		if mm_results == nil {
			mmContainsComment.t.Fatal("No results are set for the RepositoryMock.ContainsComment")
		}
		return (*mm_results).b1, (*mm_results).err
	}
	if mmContainsComment.funcContainsComment != nil {
		return mmContainsComment.funcContainsComment(ctx, id)
	}
	mmContainsComment.t.Fatalf("Unexpected call to RepositoryMock.ContainsComment. %v %v", ctx, id)
	return
}

// ContainsCommentAfterCounter returns a count of finished RepositoryMock.ContainsComment invocations
func (mmContainsComment *RepositoryMock) ContainsCommentAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmContainsComment.afterContainsCommentCounter)
}

// ContainsCommentBeforeCounter returns a count of RepositoryMock.ContainsComment invocations
func (mmContainsComment *RepositoryMock) ContainsCommentBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmContainsComment.beforeContainsCommentCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.ContainsComment.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmContainsComment *mRepositoryMockContainsComment) Calls() []*RepositoryMockContainsCommentParams {
	mmContainsComment.mutex.RLock()

	argCopy := make([]*RepositoryMockContainsCommentParams, len(mmContainsComment.callArgs))
	copy(argCopy, mmContainsComment.callArgs)

	mmContainsComment.mutex.RUnlock()

	return argCopy
}

// MinimockContainsCommentDone returns true if the count of the ContainsComment invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockContainsCommentDone() bool {
	for _, e := range m.ContainsCommentMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ContainsCommentMock.invocationsDone()
}

// MinimockContainsCommentInspect logs each unmet expectation
func (m *RepositoryMock) MinimockContainsCommentInspect() {
	for _, e := range m.ContainsCommentMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.ContainsComment with params: %#v", *e.params)
		}
	}

	afterContainsCommentCounter := mm_atomic.LoadUint64(&m.afterContainsCommentCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ContainsCommentMock.defaultExpectation != nil && afterContainsCommentCounter < 1 {
		if m.ContainsCommentMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.ContainsComment")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.ContainsComment with params: %#v", *m.ContainsCommentMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcContainsComment != nil && afterContainsCommentCounter < 1 {
		m.t.Error("Expected call to RepositoryMock.ContainsComment")
	}

	if !m.ContainsCommentMock.invocationsDone() && afterContainsCommentCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.ContainsComment but found %d calls",
			mm_atomic.LoadUint64(&m.ContainsCommentMock.expectedInvocations), afterContainsCommentCounter)
	}
}

type mRepositoryMockContainsPost struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockContainsPostExpectation
	expectations       []*RepositoryMockContainsPostExpectation

	callArgs []*RepositoryMockContainsPostParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryMockContainsPostExpectation specifies expectation struct of the Repository.ContainsPost
type RepositoryMockContainsPostExpectation struct {
	mock      *RepositoryMock
	params    *RepositoryMockContainsPostParams
	paramPtrs *RepositoryMockContainsPostParamPtrs
	results   *RepositoryMockContainsPostResults
	Counter   uint64
}

// RepositoryMockContainsPostParams contains parameters of the Repository.ContainsPost
type RepositoryMockContainsPostParams struct {
	ctx context.Context
	id  int
}

// RepositoryMockContainsPostParamPtrs contains pointers to parameters of the Repository.ContainsPost
type RepositoryMockContainsPostParamPtrs struct {
	ctx *context.Context
	id  *int
}

// RepositoryMockContainsPostResults contains results of the Repository.ContainsPost
type RepositoryMockContainsPostResults struct {
	b1  bool
	err error
}

// Expect sets up expected params for Repository.ContainsPost
func (mmContainsPost *mRepositoryMockContainsPost) Expect(ctx context.Context, id int) *mRepositoryMockContainsPost {
	if mmContainsPost.mock.funcContainsPost != nil {
		mmContainsPost.mock.t.Fatalf("RepositoryMock.ContainsPost mock is already set by Set")
	}

	if mmContainsPost.defaultExpectation == nil {
		mmContainsPost.defaultExpectation = &RepositoryMockContainsPostExpectation{}
	}

	if mmContainsPost.defaultExpectation.paramPtrs != nil {
		mmContainsPost.mock.t.Fatalf("RepositoryMock.ContainsPost mock is already set by ExpectParams functions")
	}

	mmContainsPost.defaultExpectation.params = &RepositoryMockContainsPostParams{ctx, id}
	for _, e := range mmContainsPost.expectations {
		if minimock.Equal(e.params, mmContainsPost.defaultExpectation.params) {
			mmContainsPost.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmContainsPost.defaultExpectation.params)
		}
	}

	return mmContainsPost
}

// ExpectCtxParam1 sets up expected param ctx for Repository.ContainsPost
func (mmContainsPost *mRepositoryMockContainsPost) ExpectCtxParam1(ctx context.Context) *mRepositoryMockContainsPost {
	if mmContainsPost.mock.funcContainsPost != nil {
		mmContainsPost.mock.t.Fatalf("RepositoryMock.ContainsPost mock is already set by Set")
	}

	if mmContainsPost.defaultExpectation == nil {
		mmContainsPost.defaultExpectation = &RepositoryMockContainsPostExpectation{}
	}

	if mmContainsPost.defaultExpectation.params != nil {
		mmContainsPost.mock.t.Fatalf("RepositoryMock.ContainsPost mock is already set by Expect")
	}

	if mmContainsPost.defaultExpectation.paramPtrs == nil {
		mmContainsPost.defaultExpectation.paramPtrs = &RepositoryMockContainsPostParamPtrs{}
	}
	mmContainsPost.defaultExpectation.paramPtrs.ctx = &ctx

	return mmContainsPost
}

// ExpectIdParam2 sets up expected param id for Repository.ContainsPost
func (mmContainsPost *mRepositoryMockContainsPost) ExpectIdParam2(id int) *mRepositoryMockContainsPost {
	if mmContainsPost.mock.funcContainsPost != nil {
		mmContainsPost.mock.t.Fatalf("RepositoryMock.ContainsPost mock is already set by Set")
	}

	if mmContainsPost.defaultExpectation == nil {
		mmContainsPost.defaultExpectation = &RepositoryMockContainsPostExpectation{}
	}

	if mmContainsPost.defaultExpectation.params != nil {
		mmContainsPost.mock.t.Fatalf("RepositoryMock.ContainsPost mock is already set by Expect")
	}

	if mmContainsPost.defaultExpectation.paramPtrs == nil {
		mmContainsPost.defaultExpectation.paramPtrs = &RepositoryMockContainsPostParamPtrs{}
	}
	mmContainsPost.defaultExpectation.paramPtrs.id = &id

	return mmContainsPost
}

// Inspect accepts an inspector function that has same arguments as the Repository.ContainsPost
func (mmContainsPost *mRepositoryMockContainsPost) Inspect(f func(ctx context.Context, id int)) *mRepositoryMockContainsPost {
	if mmContainsPost.mock.inspectFuncContainsPost != nil {
		mmContainsPost.mock.t.Fatalf("Inspect function is already set for RepositoryMock.ContainsPost")
	}

	mmContainsPost.mock.inspectFuncContainsPost = f

	return mmContainsPost
}

// Return sets up results that will be returned by Repository.ContainsPost
func (mmContainsPost *mRepositoryMockContainsPost) Return(b1 bool, err error) *RepositoryMock {
	if mmContainsPost.mock.funcContainsPost != nil {
		mmContainsPost.mock.t.Fatalf("RepositoryMock.ContainsPost mock is already set by Set")
	}

	if mmContainsPost.defaultExpectation == nil {
		mmContainsPost.defaultExpectation = &RepositoryMockContainsPostExpectation{mock: mmContainsPost.mock}
	}
	mmContainsPost.defaultExpectation.results = &RepositoryMockContainsPostResults{b1, err}
	return mmContainsPost.mock
}

// Set uses given function f to mock the Repository.ContainsPost method
func (mmContainsPost *mRepositoryMockContainsPost) Set(f func(ctx context.Context, id int) (b1 bool, err error)) *RepositoryMock {
	if mmContainsPost.defaultExpectation != nil {
		mmContainsPost.mock.t.Fatalf("Default expectation is already set for the Repository.ContainsPost method")
	}

	if len(mmContainsPost.expectations) > 0 {
		mmContainsPost.mock.t.Fatalf("Some expectations are already set for the Repository.ContainsPost method")
	}

	mmContainsPost.mock.funcContainsPost = f
	return mmContainsPost.mock
}

// When sets expectation for the Repository.ContainsPost which will trigger the result defined by the following
// Then helper
func (mmContainsPost *mRepositoryMockContainsPost) When(ctx context.Context, id int) *RepositoryMockContainsPostExpectation {
	if mmContainsPost.mock.funcContainsPost != nil {
		mmContainsPost.mock.t.Fatalf("RepositoryMock.ContainsPost mock is already set by Set")
	}

	expectation := &RepositoryMockContainsPostExpectation{
		mock:   mmContainsPost.mock,
		params: &RepositoryMockContainsPostParams{ctx, id},
	}
	mmContainsPost.expectations = append(mmContainsPost.expectations, expectation)
	return expectation
}

// Then sets up Repository.ContainsPost return parameters for the expectation previously defined by the When method
func (e *RepositoryMockContainsPostExpectation) Then(b1 bool, err error) *RepositoryMock {
	e.results = &RepositoryMockContainsPostResults{b1, err}
	return e.mock
}

// Times sets number of times Repository.ContainsPost should be invoked
func (mmContainsPost *mRepositoryMockContainsPost) Times(n uint64) *mRepositoryMockContainsPost {
	if n == 0 {
		mmContainsPost.mock.t.Fatalf("Times of RepositoryMock.ContainsPost mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmContainsPost.expectedInvocations, n)
	return mmContainsPost
}

func (mmContainsPost *mRepositoryMockContainsPost) invocationsDone() bool {
	if len(mmContainsPost.expectations) == 0 && mmContainsPost.defaultExpectation == nil && mmContainsPost.mock.funcContainsPost == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmContainsPost.mock.afterContainsPostCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmContainsPost.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ContainsPost implements repository.Repository
func (mmContainsPost *RepositoryMock) ContainsPost(ctx context.Context, id int) (b1 bool, err error) {
	mm_atomic.AddUint64(&mmContainsPost.beforeContainsPostCounter, 1)
	defer mm_atomic.AddUint64(&mmContainsPost.afterContainsPostCounter, 1)

	if mmContainsPost.inspectFuncContainsPost != nil {
		mmContainsPost.inspectFuncContainsPost(ctx, id)
	}

	mm_params := RepositoryMockContainsPostParams{ctx, id}

	// Record call args
	mmContainsPost.ContainsPostMock.mutex.Lock()
	mmContainsPost.ContainsPostMock.callArgs = append(mmContainsPost.ContainsPostMock.callArgs, &mm_params)
	mmContainsPost.ContainsPostMock.mutex.Unlock()

	for _, e := range mmContainsPost.ContainsPostMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1, e.results.err
		}
	}

	if mmContainsPost.ContainsPostMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmContainsPost.ContainsPostMock.defaultExpectation.Counter, 1)
		mm_want := mmContainsPost.ContainsPostMock.defaultExpectation.params
		mm_want_ptrs := mmContainsPost.ContainsPostMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockContainsPostParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmContainsPost.t.Errorf("RepositoryMock.ContainsPost got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmContainsPost.t.Errorf("RepositoryMock.ContainsPost got unexpected parameter id, want: %#v, got: %#v%s\n", *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmContainsPost.t.Errorf("RepositoryMock.ContainsPost got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmContainsPost.ContainsPostMock.defaultExpectation.results
		if mm_results == nil {
			mmContainsPost.t.Fatal("No results are set for the RepositoryMock.ContainsPost")
		}
		return (*mm_results).b1, (*mm_results).err
	}
	if mmContainsPost.funcContainsPost != nil {
		return mmContainsPost.funcContainsPost(ctx, id)
	}
	mmContainsPost.t.Fatalf("Unexpected call to RepositoryMock.ContainsPost. %v %v", ctx, id)
	return
}

// ContainsPostAfterCounter returns a count of finished RepositoryMock.ContainsPost invocations
func (mmContainsPost *RepositoryMock) ContainsPostAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmContainsPost.afterContainsPostCounter)
}

// ContainsPostBeforeCounter returns a count of RepositoryMock.ContainsPost invocations
func (mmContainsPost *RepositoryMock) ContainsPostBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmContainsPost.beforeContainsPostCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.ContainsPost.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmContainsPost *mRepositoryMockContainsPost) Calls() []*RepositoryMockContainsPostParams {
	mmContainsPost.mutex.RLock()

	argCopy := make([]*RepositoryMockContainsPostParams, len(mmContainsPost.callArgs))
	copy(argCopy, mmContainsPost.callArgs)

	mmContainsPost.mutex.RUnlock()

	return argCopy
}

// MinimockContainsPostDone returns true if the count of the ContainsPost invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockContainsPostDone() bool {
	for _, e := range m.ContainsPostMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ContainsPostMock.invocationsDone()
}

// MinimockContainsPostInspect logs each unmet expectation
func (m *RepositoryMock) MinimockContainsPostInspect() {
	for _, e := range m.ContainsPostMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.ContainsPost with params: %#v", *e.params)
		}
	}

	afterContainsPostCounter := mm_atomic.LoadUint64(&m.afterContainsPostCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ContainsPostMock.defaultExpectation != nil && afterContainsPostCounter < 1 {
		if m.ContainsPostMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.ContainsPost")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.ContainsPost with params: %#v", *m.ContainsPostMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcContainsPost != nil && afterContainsPostCounter < 1 {
		m.t.Error("Expected call to RepositoryMock.ContainsPost")
	}

	if !m.ContainsPostMock.invocationsDone() && afterContainsPostCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.ContainsPost but found %d calls",
			mm_atomic.LoadUint64(&m.ContainsPostMock.expectedInvocations), afterContainsPostCounter)
	}
}

type mRepositoryMockCreateComment struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockCreateCommentExpectation
	expectations       []*RepositoryMockCreateCommentExpectation

	callArgs []*RepositoryMockCreateCommentParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryMockCreateCommentExpectation specifies expectation struct of the Repository.CreateComment
type RepositoryMockCreateCommentExpectation struct {
	mock      *RepositoryMock
	params    *RepositoryMockCreateCommentParams
	paramPtrs *RepositoryMockCreateCommentParamPtrs
	results   *RepositoryMockCreateCommentResults
	Counter   uint64
}

// RepositoryMockCreateCommentParams contains parameters of the Repository.CreateComment
type RepositoryMockCreateCommentParams struct {
	ctx     context.Context
	comment *domain.Comment
}

// RepositoryMockCreateCommentParamPtrs contains pointers to parameters of the Repository.CreateComment
type RepositoryMockCreateCommentParamPtrs struct {
	ctx     *context.Context
	comment **domain.Comment
}

// RepositoryMockCreateCommentResults contains results of the Repository.CreateComment
type RepositoryMockCreateCommentResults struct {
	cp1 *domain.Comment
	err error
}

// Expect sets up expected params for Repository.CreateComment
func (mmCreateComment *mRepositoryMockCreateComment) Expect(ctx context.Context, comment *domain.Comment) *mRepositoryMockCreateComment {
	if mmCreateComment.mock.funcCreateComment != nil {
		mmCreateComment.mock.t.Fatalf("RepositoryMock.CreateComment mock is already set by Set")
	}

	if mmCreateComment.defaultExpectation == nil {
		mmCreateComment.defaultExpectation = &RepositoryMockCreateCommentExpectation{}
	}

	if mmCreateComment.defaultExpectation.paramPtrs != nil {
		mmCreateComment.mock.t.Fatalf("RepositoryMock.CreateComment mock is already set by ExpectParams functions")
	}

	mmCreateComment.defaultExpectation.params = &RepositoryMockCreateCommentParams{ctx, comment}
	for _, e := range mmCreateComment.expectations {
		if minimock.Equal(e.params, mmCreateComment.defaultExpectation.params) {
			mmCreateComment.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateComment.defaultExpectation.params)
		}
	}

	return mmCreateComment
}

// ExpectCtxParam1 sets up expected param ctx for Repository.CreateComment
func (mmCreateComment *mRepositoryMockCreateComment) ExpectCtxParam1(ctx context.Context) *mRepositoryMockCreateComment {
	if mmCreateComment.mock.funcCreateComment != nil {
		mmCreateComment.mock.t.Fatalf("RepositoryMock.CreateComment mock is already set by Set")
	}

	if mmCreateComment.defaultExpectation == nil {
		mmCreateComment.defaultExpectation = &RepositoryMockCreateCommentExpectation{}
	}

	if mmCreateComment.defaultExpectation.params != nil {
		mmCreateComment.mock.t.Fatalf("RepositoryMock.CreateComment mock is already set by Expect")
	}

	if mmCreateComment.defaultExpectation.paramPtrs == nil {
		mmCreateComment.defaultExpectation.paramPtrs = &RepositoryMockCreateCommentParamPtrs{}
	}
	mmCreateComment.defaultExpectation.paramPtrs.ctx = &ctx

	return mmCreateComment
}

// ExpectCommentParam2 sets up expected param comment for Repository.CreateComment
func (mmCreateComment *mRepositoryMockCreateComment) ExpectCommentParam2(comment *domain.Comment) *mRepositoryMockCreateComment {
	if mmCreateComment.mock.funcCreateComment != nil {
		mmCreateComment.mock.t.Fatalf("RepositoryMock.CreateComment mock is already set by Set")
	}

	if mmCreateComment.defaultExpectation == nil {
		mmCreateComment.defaultExpectation = &RepositoryMockCreateCommentExpectation{}
	}

	if mmCreateComment.defaultExpectation.params != nil {
		mmCreateComment.mock.t.Fatalf("RepositoryMock.CreateComment mock is already set by Expect")
	}

	if mmCreateComment.defaultExpectation.paramPtrs == nil {
		mmCreateComment.defaultExpectation.paramPtrs = &RepositoryMockCreateCommentParamPtrs{}
	}
	mmCreateComment.defaultExpectation.paramPtrs.comment = &comment

	return mmCreateComment
}

// Inspect accepts an inspector function that has same arguments as the Repository.CreateComment
func (mmCreateComment *mRepositoryMockCreateComment) Inspect(f func(ctx context.Context, comment *domain.Comment)) *mRepositoryMockCreateComment {
	if mmCreateComment.mock.inspectFuncCreateComment != nil {
		mmCreateComment.mock.t.Fatalf("Inspect function is already set for RepositoryMock.CreateComment")
	}

	mmCreateComment.mock.inspectFuncCreateComment = f

	return mmCreateComment
}

// Return sets up results that will be returned by Repository.CreateComment
func (mmCreateComment *mRepositoryMockCreateComment) Return(cp1 *domain.Comment, err error) *RepositoryMock {
	if mmCreateComment.mock.funcCreateComment != nil {
		mmCreateComment.mock.t.Fatalf("RepositoryMock.CreateComment mock is already set by Set")
	}

	if mmCreateComment.defaultExpectation == nil {
		mmCreateComment.defaultExpectation = &RepositoryMockCreateCommentExpectation{mock: mmCreateComment.mock}
	}
	mmCreateComment.defaultExpectation.results = &RepositoryMockCreateCommentResults{cp1, err}
	return mmCreateComment.mock
}

// Set uses given function f to mock the Repository.CreateComment method
func (mmCreateComment *mRepositoryMockCreateComment) Set(f func(ctx context.Context, comment *domain.Comment) (cp1 *domain.Comment, err error)) *RepositoryMock {
	if mmCreateComment.defaultExpectation != nil {
		mmCreateComment.mock.t.Fatalf("Default expectation is already set for the Repository.CreateComment method")
	}

	if len(mmCreateComment.expectations) > 0 {
		mmCreateComment.mock.t.Fatalf("Some expectations are already set for the Repository.CreateComment method")
	}

	mmCreateComment.mock.funcCreateComment = f
	return mmCreateComment.mock
}

// When sets expectation for the Repository.CreateComment which will trigger the result defined by the following
// Then helper
func (mmCreateComment *mRepositoryMockCreateComment) When(ctx context.Context, comment *domain.Comment) *RepositoryMockCreateCommentExpectation {
	if mmCreateComment.mock.funcCreateComment != nil {
		mmCreateComment.mock.t.Fatalf("RepositoryMock.CreateComment mock is already set by Set")
	}

	expectation := &RepositoryMockCreateCommentExpectation{
		mock:   mmCreateComment.mock,
		params: &RepositoryMockCreateCommentParams{ctx, comment},
	}
	mmCreateComment.expectations = append(mmCreateComment.expectations, expectation)
	return expectation
}

// Then sets up Repository.CreateComment return parameters for the expectation previously defined by the When method
func (e *RepositoryMockCreateCommentExpectation) Then(cp1 *domain.Comment, err error) *RepositoryMock {
	e.results = &RepositoryMockCreateCommentResults{cp1, err}
	return e.mock
}

// Times sets number of times Repository.CreateComment should be invoked
func (mmCreateComment *mRepositoryMockCreateComment) Times(n uint64) *mRepositoryMockCreateComment {
	if n == 0 {
		mmCreateComment.mock.t.Fatalf("Times of RepositoryMock.CreateComment mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateComment.expectedInvocations, n)
	return mmCreateComment
}

func (mmCreateComment *mRepositoryMockCreateComment) invocationsDone() bool {
	if len(mmCreateComment.expectations) == 0 && mmCreateComment.defaultExpectation == nil && mmCreateComment.mock.funcCreateComment == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateComment.mock.afterCreateCommentCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateComment.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateComment implements repository.Repository
func (mmCreateComment *RepositoryMock) CreateComment(ctx context.Context, comment *domain.Comment) (cp1 *domain.Comment, err error) {
	mm_atomic.AddUint64(&mmCreateComment.beforeCreateCommentCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateComment.afterCreateCommentCounter, 1)

	if mmCreateComment.inspectFuncCreateComment != nil {
		mmCreateComment.inspectFuncCreateComment(ctx, comment)
	}

	mm_params := RepositoryMockCreateCommentParams{ctx, comment}

	// Record call args
	mmCreateComment.CreateCommentMock.mutex.Lock()
	mmCreateComment.CreateCommentMock.callArgs = append(mmCreateComment.CreateCommentMock.callArgs, &mm_params)
	mmCreateComment.CreateCommentMock.mutex.Unlock()

	for _, e := range mmCreateComment.CreateCommentMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmCreateComment.CreateCommentMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateComment.CreateCommentMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateComment.CreateCommentMock.defaultExpectation.params
		mm_want_ptrs := mmCreateComment.CreateCommentMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockCreateCommentParams{ctx, comment}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateComment.t.Errorf("RepositoryMock.CreateComment got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.comment != nil && !minimock.Equal(*mm_want_ptrs.comment, mm_got.comment) {
				mmCreateComment.t.Errorf("RepositoryMock.CreateComment got unexpected parameter comment, want: %#v, got: %#v%s\n", *mm_want_ptrs.comment, mm_got.comment, minimock.Diff(*mm_want_ptrs.comment, mm_got.comment))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateComment.t.Errorf("RepositoryMock.CreateComment got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateComment.CreateCommentMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateComment.t.Fatal("No results are set for the RepositoryMock.CreateComment")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmCreateComment.funcCreateComment != nil {
		return mmCreateComment.funcCreateComment(ctx, comment)
	}
	mmCreateComment.t.Fatalf("Unexpected call to RepositoryMock.CreateComment. %v %v", ctx, comment)
	return
}

// CreateCommentAfterCounter returns a count of finished RepositoryMock.CreateComment invocations
func (mmCreateComment *RepositoryMock) CreateCommentAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateComment.afterCreateCommentCounter)
}

// CreateCommentBeforeCounter returns a count of RepositoryMock.CreateComment invocations
func (mmCreateComment *RepositoryMock) CreateCommentBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateComment.beforeCreateCommentCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.CreateComment.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateComment *mRepositoryMockCreateComment) Calls() []*RepositoryMockCreateCommentParams {
	mmCreateComment.mutex.RLock()

	argCopy := make([]*RepositoryMockCreateCommentParams, len(mmCreateComment.callArgs))
	copy(argCopy, mmCreateComment.callArgs)

	mmCreateComment.mutex.RUnlock()

	return argCopy
}

// MinimockCreateCommentDone returns true if the count of the CreateComment invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockCreateCommentDone() bool {
	for _, e := range m.CreateCommentMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateCommentMock.invocationsDone()
}

// MinimockCreateCommentInspect logs each unmet expectation
func (m *RepositoryMock) MinimockCreateCommentInspect() {
	for _, e := range m.CreateCommentMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.CreateComment with params: %#v", *e.params)
		}
	}

	afterCreateCommentCounter := mm_atomic.LoadUint64(&m.afterCreateCommentCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateCommentMock.defaultExpectation != nil && afterCreateCommentCounter < 1 {
		if m.CreateCommentMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.CreateComment")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.CreateComment with params: %#v", *m.CreateCommentMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateComment != nil && afterCreateCommentCounter < 1 {
		m.t.Error("Expected call to RepositoryMock.CreateComment")
	}

	if !m.CreateCommentMock.invocationsDone() && afterCreateCommentCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.CreateComment but found %d calls",
			mm_atomic.LoadUint64(&m.CreateCommentMock.expectedInvocations), afterCreateCommentCounter)
	}
}

type mRepositoryMockCreatePost struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockCreatePostExpectation
	expectations       []*RepositoryMockCreatePostExpectation

	callArgs []*RepositoryMockCreatePostParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryMockCreatePostExpectation specifies expectation struct of the Repository.CreatePost
type RepositoryMockCreatePostExpectation struct {
	mock      *RepositoryMock
	params    *RepositoryMockCreatePostParams
	paramPtrs *RepositoryMockCreatePostParamPtrs
	results   *RepositoryMockCreatePostResults
	Counter   uint64
}

// RepositoryMockCreatePostParams contains parameters of the Repository.CreatePost
type RepositoryMockCreatePostParams struct {
	ctx  context.Context
	post *domain.Post
}

// RepositoryMockCreatePostParamPtrs contains pointers to parameters of the Repository.CreatePost
type RepositoryMockCreatePostParamPtrs struct {
	ctx  *context.Context
	post **domain.Post
}

// RepositoryMockCreatePostResults contains results of the Repository.CreatePost
type RepositoryMockCreatePostResults struct {
	pp1 *domain.Post
	err error
}

// Expect sets up expected params for Repository.CreatePost
func (mmCreatePost *mRepositoryMockCreatePost) Expect(ctx context.Context, post *domain.Post) *mRepositoryMockCreatePost {
	if mmCreatePost.mock.funcCreatePost != nil {
		mmCreatePost.mock.t.Fatalf("RepositoryMock.CreatePost mock is already set by Set")
	}

	if mmCreatePost.defaultExpectation == nil {
		mmCreatePost.defaultExpectation = &RepositoryMockCreatePostExpectation{}
	}

	if mmCreatePost.defaultExpectation.paramPtrs != nil {
		mmCreatePost.mock.t.Fatalf("RepositoryMock.CreatePost mock is already set by ExpectParams functions")
	}

	mmCreatePost.defaultExpectation.params = &RepositoryMockCreatePostParams{ctx, post}
	for _, e := range mmCreatePost.expectations {
		if minimock.Equal(e.params, mmCreatePost.defaultExpectation.params) {
			mmCreatePost.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreatePost.defaultExpectation.params)
		}
	}

	return mmCreatePost
}

// ExpectCtxParam1 sets up expected param ctx for Repository.CreatePost
func (mmCreatePost *mRepositoryMockCreatePost) ExpectCtxParam1(ctx context.Context) *mRepositoryMockCreatePost {
	if mmCreatePost.mock.funcCreatePost != nil {
		mmCreatePost.mock.t.Fatalf("RepositoryMock.CreatePost mock is already set by Set")
	}

	if mmCreatePost.defaultExpectation == nil {
		mmCreatePost.defaultExpectation = &RepositoryMockCreatePostExpectation{}
	}

	if mmCreatePost.defaultExpectation.params != nil {
		mmCreatePost.mock.t.Fatalf("RepositoryMock.CreatePost mock is already set by Expect")
	}

	if mmCreatePost.defaultExpectation.paramPtrs == nil {
		mmCreatePost.defaultExpectation.paramPtrs = &RepositoryMockCreatePostParamPtrs{}
	}
	mmCreatePost.defaultExpectation.paramPtrs.ctx = &ctx

	return mmCreatePost
}

// ExpectPostParam2 sets up expected param post for Repository.CreatePost
func (mmCreatePost *mRepositoryMockCreatePost) ExpectPostParam2(post *domain.Post) *mRepositoryMockCreatePost {
	if mmCreatePost.mock.funcCreatePost != nil {
		mmCreatePost.mock.t.Fatalf("RepositoryMock.CreatePost mock is already set by Set")
	}

	if mmCreatePost.defaultExpectation == nil {
		mmCreatePost.defaultExpectation = &RepositoryMockCreatePostExpectation{}
	}

	if mmCreatePost.defaultExpectation.params != nil {
		mmCreatePost.mock.t.Fatalf("RepositoryMock.CreatePost mock is already set by Expect")
	}

	if mmCreatePost.defaultExpectation.paramPtrs == nil {
		mmCreatePost.defaultExpectation.paramPtrs = &RepositoryMockCreatePostParamPtrs{}
	}
	mmCreatePost.defaultExpectation.paramPtrs.post = &post

	return mmCreatePost
}

// Inspect accepts an inspector function that has same arguments as the Repository.CreatePost
func (mmCreatePost *mRepositoryMockCreatePost) Inspect(f func(ctx context.Context, post *domain.Post)) *mRepositoryMockCreatePost {
	if mmCreatePost.mock.inspectFuncCreatePost != nil {
		mmCreatePost.mock.t.Fatalf("Inspect function is already set for RepositoryMock.CreatePost")
	}

	mmCreatePost.mock.inspectFuncCreatePost = f

	return mmCreatePost
}

// Return sets up results that will be returned by Repository.CreatePost
func (mmCreatePost *mRepositoryMockCreatePost) Return(pp1 *domain.Post, err error) *RepositoryMock {
	if mmCreatePost.mock.funcCreatePost != nil {
		mmCreatePost.mock.t.Fatalf("RepositoryMock.CreatePost mock is already set by Set")
	}

	if mmCreatePost.defaultExpectation == nil {
		mmCreatePost.defaultExpectation = &RepositoryMockCreatePostExpectation{mock: mmCreatePost.mock}
	}
	mmCreatePost.defaultExpectation.results = &RepositoryMockCreatePostResults{pp1, err}
	return mmCreatePost.mock
}

// Set uses given function f to mock the Repository.CreatePost method
func (mmCreatePost *mRepositoryMockCreatePost) Set(f func(ctx context.Context, post *domain.Post) (pp1 *domain.Post, err error)) *RepositoryMock {
	if mmCreatePost.defaultExpectation != nil {
		mmCreatePost.mock.t.Fatalf("Default expectation is already set for the Repository.CreatePost method")
	}

	if len(mmCreatePost.expectations) > 0 {
		mmCreatePost.mock.t.Fatalf("Some expectations are already set for the Repository.CreatePost method")
	}

	mmCreatePost.mock.funcCreatePost = f
	return mmCreatePost.mock
}

// When sets expectation for the Repository.CreatePost which will trigger the result defined by the following
// Then helper
func (mmCreatePost *mRepositoryMockCreatePost) When(ctx context.Context, post *domain.Post) *RepositoryMockCreatePostExpectation {
	if mmCreatePost.mock.funcCreatePost != nil {
		mmCreatePost.mock.t.Fatalf("RepositoryMock.CreatePost mock is already set by Set")
	}

	expectation := &RepositoryMockCreatePostExpectation{
		mock:   mmCreatePost.mock,
		params: &RepositoryMockCreatePostParams{ctx, post},
	}
	mmCreatePost.expectations = append(mmCreatePost.expectations, expectation)
	return expectation
}

// Then sets up Repository.CreatePost return parameters for the expectation previously defined by the When method
func (e *RepositoryMockCreatePostExpectation) Then(pp1 *domain.Post, err error) *RepositoryMock {
	e.results = &RepositoryMockCreatePostResults{pp1, err}
	return e.mock
}

// Times sets number of times Repository.CreatePost should be invoked
func (mmCreatePost *mRepositoryMockCreatePost) Times(n uint64) *mRepositoryMockCreatePost {
	if n == 0 {
		mmCreatePost.mock.t.Fatalf("Times of RepositoryMock.CreatePost mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreatePost.expectedInvocations, n)
	return mmCreatePost
}

func (mmCreatePost *mRepositoryMockCreatePost) invocationsDone() bool {
	if len(mmCreatePost.expectations) == 0 && mmCreatePost.defaultExpectation == nil && mmCreatePost.mock.funcCreatePost == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreatePost.mock.afterCreatePostCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreatePost.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreatePost implements repository.Repository
func (mmCreatePost *RepositoryMock) CreatePost(ctx context.Context, post *domain.Post) (pp1 *domain.Post, err error) {
	mm_atomic.AddUint64(&mmCreatePost.beforeCreatePostCounter, 1)
	defer mm_atomic.AddUint64(&mmCreatePost.afterCreatePostCounter, 1)

	if mmCreatePost.inspectFuncCreatePost != nil {
		mmCreatePost.inspectFuncCreatePost(ctx, post)
	}

	mm_params := RepositoryMockCreatePostParams{ctx, post}

	// Record call args
	mmCreatePost.CreatePostMock.mutex.Lock()
	mmCreatePost.CreatePostMock.callArgs = append(mmCreatePost.CreatePostMock.callArgs, &mm_params)
	mmCreatePost.CreatePostMock.mutex.Unlock()

	for _, e := range mmCreatePost.CreatePostMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp1, e.results.err
		}
	}

	if mmCreatePost.CreatePostMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreatePost.CreatePostMock.defaultExpectation.Counter, 1)
		mm_want := mmCreatePost.CreatePostMock.defaultExpectation.params
		mm_want_ptrs := mmCreatePost.CreatePostMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockCreatePostParams{ctx, post}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreatePost.t.Errorf("RepositoryMock.CreatePost got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.post != nil && !minimock.Equal(*mm_want_ptrs.post, mm_got.post) {
				mmCreatePost.t.Errorf("RepositoryMock.CreatePost got unexpected parameter post, want: %#v, got: %#v%s\n", *mm_want_ptrs.post, mm_got.post, minimock.Diff(*mm_want_ptrs.post, mm_got.post))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreatePost.t.Errorf("RepositoryMock.CreatePost got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreatePost.CreatePostMock.defaultExpectation.results
		if mm_results == nil {
			mmCreatePost.t.Fatal("No results are set for the RepositoryMock.CreatePost")
		}
		return (*mm_results).pp1, (*mm_results).err
	}
	if mmCreatePost.funcCreatePost != nil {
		return mmCreatePost.funcCreatePost(ctx, post)
	}
	mmCreatePost.t.Fatalf("Unexpected call to RepositoryMock.CreatePost. %v %v", ctx, post)
	return
}

// CreatePostAfterCounter returns a count of finished RepositoryMock.CreatePost invocations
func (mmCreatePost *RepositoryMock) CreatePostAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreatePost.afterCreatePostCounter)
}

// CreatePostBeforeCounter returns a count of RepositoryMock.CreatePost invocations
func (mmCreatePost *RepositoryMock) CreatePostBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreatePost.beforeCreatePostCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.CreatePost.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreatePost *mRepositoryMockCreatePost) Calls() []*RepositoryMockCreatePostParams {
	mmCreatePost.mutex.RLock()

	argCopy := make([]*RepositoryMockCreatePostParams, len(mmCreatePost.callArgs))
	copy(argCopy, mmCreatePost.callArgs)

	mmCreatePost.mutex.RUnlock()

	return argCopy
}

// MinimockCreatePostDone returns true if the count of the CreatePost invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockCreatePostDone() bool {
	for _, e := range m.CreatePostMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreatePostMock.invocationsDone()
}

// MinimockCreatePostInspect logs each unmet expectation
func (m *RepositoryMock) MinimockCreatePostInspect() {
	for _, e := range m.CreatePostMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.CreatePost with params: %#v", *e.params)
		}
	}

	afterCreatePostCounter := mm_atomic.LoadUint64(&m.afterCreatePostCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreatePostMock.defaultExpectation != nil && afterCreatePostCounter < 1 {
		if m.CreatePostMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.CreatePost")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.CreatePost with params: %#v", *m.CreatePostMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreatePost != nil && afterCreatePostCounter < 1 {
		m.t.Error("Expected call to RepositoryMock.CreatePost")
	}

	if !m.CreatePostMock.invocationsDone() && afterCreatePostCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.CreatePost but found %d calls",
			mm_atomic.LoadUint64(&m.CreatePostMock.expectedInvocations), afterCreatePostCounter)
	}
}

type mRepositoryMockDisableComments struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockDisableCommentsExpectation
	expectations       []*RepositoryMockDisableCommentsExpectation

	callArgs []*RepositoryMockDisableCommentsParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryMockDisableCommentsExpectation specifies expectation struct of the Repository.DisableComments
type RepositoryMockDisableCommentsExpectation struct {
	mock      *RepositoryMock
	params    *RepositoryMockDisableCommentsParams
	paramPtrs *RepositoryMockDisableCommentsParamPtrs
	results   *RepositoryMockDisableCommentsResults
	Counter   uint64
}

// RepositoryMockDisableCommentsParams contains parameters of the Repository.DisableComments
type RepositoryMockDisableCommentsParams struct {
	ctx    context.Context
	postID int
}

// RepositoryMockDisableCommentsParamPtrs contains pointers to parameters of the Repository.DisableComments
type RepositoryMockDisableCommentsParamPtrs struct {
	ctx    *context.Context
	postID *int
}

// RepositoryMockDisableCommentsResults contains results of the Repository.DisableComments
type RepositoryMockDisableCommentsResults struct {
	err error
}

// Expect sets up expected params for Repository.DisableComments
func (mmDisableComments *mRepositoryMockDisableComments) Expect(ctx context.Context, postID int) *mRepositoryMockDisableComments {
	if mmDisableComments.mock.funcDisableComments != nil {
		mmDisableComments.mock.t.Fatalf("RepositoryMock.DisableComments mock is already set by Set")
	}

	if mmDisableComments.defaultExpectation == nil {
		mmDisableComments.defaultExpectation = &RepositoryMockDisableCommentsExpectation{}
	}

	if mmDisableComments.defaultExpectation.paramPtrs != nil {
		mmDisableComments.mock.t.Fatalf("RepositoryMock.DisableComments mock is already set by ExpectParams functions")
	}

	mmDisableComments.defaultExpectation.params = &RepositoryMockDisableCommentsParams{ctx, postID}
	for _, e := range mmDisableComments.expectations {
		if minimock.Equal(e.params, mmDisableComments.defaultExpectation.params) {
			mmDisableComments.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDisableComments.defaultExpectation.params)
		}
	}

	return mmDisableComments
}

// ExpectCtxParam1 sets up expected param ctx for Repository.DisableComments
func (mmDisableComments *mRepositoryMockDisableComments) ExpectCtxParam1(ctx context.Context) *mRepositoryMockDisableComments {
	if mmDisableComments.mock.funcDisableComments != nil {
		mmDisableComments.mock.t.Fatalf("RepositoryMock.DisableComments mock is already set by Set")
	}

	if mmDisableComments.defaultExpectation == nil {
		mmDisableComments.defaultExpectation = &RepositoryMockDisableCommentsExpectation{}
	}

	if mmDisableComments.defaultExpectation.params != nil {
		mmDisableComments.mock.t.Fatalf("RepositoryMock.DisableComments mock is already set by Expect")
	}

	if mmDisableComments.defaultExpectation.paramPtrs == nil {
		mmDisableComments.defaultExpectation.paramPtrs = &RepositoryMockDisableCommentsParamPtrs{}
	}
	mmDisableComments.defaultExpectation.paramPtrs.ctx = &ctx

	return mmDisableComments
}

// ExpectPostIDParam2 sets up expected param postID for Repository.DisableComments
func (mmDisableComments *mRepositoryMockDisableComments) ExpectPostIDParam2(postID int) *mRepositoryMockDisableComments {
	if mmDisableComments.mock.funcDisableComments != nil {
		mmDisableComments.mock.t.Fatalf("RepositoryMock.DisableComments mock is already set by Set")
	}

	if mmDisableComments.defaultExpectation == nil {
		mmDisableComments.defaultExpectation = &RepositoryMockDisableCommentsExpectation{}
	}

	if mmDisableComments.defaultExpectation.params != nil {
		mmDisableComments.mock.t.Fatalf("RepositoryMock.DisableComments mock is already set by Expect")
	}

	if mmDisableComments.defaultExpectation.paramPtrs == nil {
		mmDisableComments.defaultExpectation.paramPtrs = &RepositoryMockDisableCommentsParamPtrs{}
	}
	mmDisableComments.defaultExpectation.paramPtrs.postID = &postID

	return mmDisableComments
}

// Inspect accepts an inspector function that has same arguments as the Repository.DisableComments
func (mmDisableComments *mRepositoryMockDisableComments) Inspect(f func(ctx context.Context, postID int)) *mRepositoryMockDisableComments {
	if mmDisableComments.mock.inspectFuncDisableComments != nil {
		mmDisableComments.mock.t.Fatalf("Inspect function is already set for RepositoryMock.DisableComments")
	}

	mmDisableComments.mock.inspectFuncDisableComments = f

	return mmDisableComments
}

// Return sets up results that will be returned by Repository.DisableComments
func (mmDisableComments *mRepositoryMockDisableComments) Return(err error) *RepositoryMock {
	if mmDisableComments.mock.funcDisableComments != nil {
		mmDisableComments.mock.t.Fatalf("RepositoryMock.DisableComments mock is already set by Set")
	}

	if mmDisableComments.defaultExpectation == nil {
		mmDisableComments.defaultExpectation = &RepositoryMockDisableCommentsExpectation{mock: mmDisableComments.mock}
	}
	mmDisableComments.defaultExpectation.results = &RepositoryMockDisableCommentsResults{err}
	return mmDisableComments.mock
}

// Set uses given function f to mock the Repository.DisableComments method
func (mmDisableComments *mRepositoryMockDisableComments) Set(f func(ctx context.Context, postID int) (err error)) *RepositoryMock {
	if mmDisableComments.defaultExpectation != nil {
		mmDisableComments.mock.t.Fatalf("Default expectation is already set for the Repository.DisableComments method")
	}

	if len(mmDisableComments.expectations) > 0 {
		mmDisableComments.mock.t.Fatalf("Some expectations are already set for the Repository.DisableComments method")
	}

	mmDisableComments.mock.funcDisableComments = f
	return mmDisableComments.mock
}

// When sets expectation for the Repository.DisableComments which will trigger the result defined by the following
// Then helper
func (mmDisableComments *mRepositoryMockDisableComments) When(ctx context.Context, postID int) *RepositoryMockDisableCommentsExpectation {
	if mmDisableComments.mock.funcDisableComments != nil {
		mmDisableComments.mock.t.Fatalf("RepositoryMock.DisableComments mock is already set by Set")
	}

	expectation := &RepositoryMockDisableCommentsExpectation{
		mock:   mmDisableComments.mock,
		params: &RepositoryMockDisableCommentsParams{ctx, postID},
	}
	mmDisableComments.expectations = append(mmDisableComments.expectations, expectation)
	return expectation
}

// Then sets up Repository.DisableComments return parameters for the expectation previously defined by the When method
func (e *RepositoryMockDisableCommentsExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockDisableCommentsResults{err}
	return e.mock
}

// Times sets number of times Repository.DisableComments should be invoked
func (mmDisableComments *mRepositoryMockDisableComments) Times(n uint64) *mRepositoryMockDisableComments {
	if n == 0 {
		mmDisableComments.mock.t.Fatalf("Times of RepositoryMock.DisableComments mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDisableComments.expectedInvocations, n)
	return mmDisableComments
}

func (mmDisableComments *mRepositoryMockDisableComments) invocationsDone() bool {
	if len(mmDisableComments.expectations) == 0 && mmDisableComments.defaultExpectation == nil && mmDisableComments.mock.funcDisableComments == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDisableComments.mock.afterDisableCommentsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDisableComments.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DisableComments implements repository.Repository
func (mmDisableComments *RepositoryMock) DisableComments(ctx context.Context, postID int) (err error) {
	mm_atomic.AddUint64(&mmDisableComments.beforeDisableCommentsCounter, 1)
	defer mm_atomic.AddUint64(&mmDisableComments.afterDisableCommentsCounter, 1)

	if mmDisableComments.inspectFuncDisableComments != nil {
		mmDisableComments.inspectFuncDisableComments(ctx, postID)
	}

	mm_params := RepositoryMockDisableCommentsParams{ctx, postID}

	// Record call args
	mmDisableComments.DisableCommentsMock.mutex.Lock()
	mmDisableComments.DisableCommentsMock.callArgs = append(mmDisableComments.DisableCommentsMock.callArgs, &mm_params)
	mmDisableComments.DisableCommentsMock.mutex.Unlock()

	for _, e := range mmDisableComments.DisableCommentsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDisableComments.DisableCommentsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDisableComments.DisableCommentsMock.defaultExpectation.Counter, 1)
		mm_want := mmDisableComments.DisableCommentsMock.defaultExpectation.params
		mm_want_ptrs := mmDisableComments.DisableCommentsMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockDisableCommentsParams{ctx, postID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDisableComments.t.Errorf("RepositoryMock.DisableComments got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.postID != nil && !minimock.Equal(*mm_want_ptrs.postID, mm_got.postID) {
				mmDisableComments.t.Errorf("RepositoryMock.DisableComments got unexpected parameter postID, want: %#v, got: %#v%s\n", *mm_want_ptrs.postID, mm_got.postID, minimock.Diff(*mm_want_ptrs.postID, mm_got.postID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDisableComments.t.Errorf("RepositoryMock.DisableComments got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDisableComments.DisableCommentsMock.defaultExpectation.results
		if mm_results == nil {
			mmDisableComments.t.Fatal("No results are set for the RepositoryMock.DisableComments")
		}
		return (*mm_results).err
	}
	if mmDisableComments.funcDisableComments != nil {
		return mmDisableComments.funcDisableComments(ctx, postID)
	}
	mmDisableComments.t.Fatalf("Unexpected call to RepositoryMock.DisableComments. %v %v", ctx, postID)
	return
}

// DisableCommentsAfterCounter returns a count of finished RepositoryMock.DisableComments invocations
func (mmDisableComments *RepositoryMock) DisableCommentsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDisableComments.afterDisableCommentsCounter)
}

// DisableCommentsBeforeCounter returns a count of RepositoryMock.DisableComments invocations
func (mmDisableComments *RepositoryMock) DisableCommentsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDisableComments.beforeDisableCommentsCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.DisableComments.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDisableComments *mRepositoryMockDisableComments) Calls() []*RepositoryMockDisableCommentsParams {
	mmDisableComments.mutex.RLock()

	argCopy := make([]*RepositoryMockDisableCommentsParams, len(mmDisableComments.callArgs))
	copy(argCopy, mmDisableComments.callArgs)

	mmDisableComments.mutex.RUnlock()

	return argCopy
}

// MinimockDisableCommentsDone returns true if the count of the DisableComments invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockDisableCommentsDone() bool {
	for _, e := range m.DisableCommentsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DisableCommentsMock.invocationsDone()
}

// MinimockDisableCommentsInspect logs each unmet expectation
func (m *RepositoryMock) MinimockDisableCommentsInspect() {
	for _, e := range m.DisableCommentsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.DisableComments with params: %#v", *e.params)
		}
	}

	afterDisableCommentsCounter := mm_atomic.LoadUint64(&m.afterDisableCommentsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DisableCommentsMock.defaultExpectation != nil && afterDisableCommentsCounter < 1 {
		if m.DisableCommentsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.DisableComments")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.DisableComments with params: %#v", *m.DisableCommentsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDisableComments != nil && afterDisableCommentsCounter < 1 {
		m.t.Error("Expected call to RepositoryMock.DisableComments")
	}

	if !m.DisableCommentsMock.invocationsDone() && afterDisableCommentsCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.DisableComments but found %d calls",
			mm_atomic.LoadUint64(&m.DisableCommentsMock.expectedInvocations), afterDisableCommentsCounter)
	}
}

type mRepositoryMockGetCommentsByParent struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetCommentsByParentExpectation
	expectations       []*RepositoryMockGetCommentsByParentExpectation

	callArgs []*RepositoryMockGetCommentsByParentParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryMockGetCommentsByParentExpectation specifies expectation struct of the Repository.GetCommentsByParent
type RepositoryMockGetCommentsByParentExpectation struct {
	mock      *RepositoryMock
	params    *RepositoryMockGetCommentsByParentParams
	paramPtrs *RepositoryMockGetCommentsByParentParamPtrs
	results   *RepositoryMockGetCommentsByParentResults
	Counter   uint64
}

// RepositoryMockGetCommentsByParentParams contains parameters of the Repository.GetCommentsByParent
type RepositoryMockGetCommentsByParentParams struct {
	ctx      context.Context
	parentId int
	limit    int
	offset   int
}

// RepositoryMockGetCommentsByParentParamPtrs contains pointers to parameters of the Repository.GetCommentsByParent
type RepositoryMockGetCommentsByParentParamPtrs struct {
	ctx      *context.Context
	parentId *int
	limit    *int
	offset   *int
}

// RepositoryMockGetCommentsByParentResults contains results of the Repository.GetCommentsByParent
type RepositoryMockGetCommentsByParentResults struct {
	cpa1 []*domain.Comment
	err  error
}

// Expect sets up expected params for Repository.GetCommentsByParent
func (mmGetCommentsByParent *mRepositoryMockGetCommentsByParent) Expect(ctx context.Context, parentId int, limit int, offset int) *mRepositoryMockGetCommentsByParent {
	if mmGetCommentsByParent.mock.funcGetCommentsByParent != nil {
		mmGetCommentsByParent.mock.t.Fatalf("RepositoryMock.GetCommentsByParent mock is already set by Set")
	}

	if mmGetCommentsByParent.defaultExpectation == nil {
		mmGetCommentsByParent.defaultExpectation = &RepositoryMockGetCommentsByParentExpectation{}
	}

	if mmGetCommentsByParent.defaultExpectation.paramPtrs != nil {
		mmGetCommentsByParent.mock.t.Fatalf("RepositoryMock.GetCommentsByParent mock is already set by ExpectParams functions")
	}

	mmGetCommentsByParent.defaultExpectation.params = &RepositoryMockGetCommentsByParentParams{ctx, parentId, limit, offset}
	for _, e := range mmGetCommentsByParent.expectations {
		if minimock.Equal(e.params, mmGetCommentsByParent.defaultExpectation.params) {
			mmGetCommentsByParent.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetCommentsByParent.defaultExpectation.params)
		}
	}

	return mmGetCommentsByParent
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetCommentsByParent
func (mmGetCommentsByParent *mRepositoryMockGetCommentsByParent) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetCommentsByParent {
	if mmGetCommentsByParent.mock.funcGetCommentsByParent != nil {
		mmGetCommentsByParent.mock.t.Fatalf("RepositoryMock.GetCommentsByParent mock is already set by Set")
	}

	if mmGetCommentsByParent.defaultExpectation == nil {
		mmGetCommentsByParent.defaultExpectation = &RepositoryMockGetCommentsByParentExpectation{}
	}

	if mmGetCommentsByParent.defaultExpectation.params != nil {
		mmGetCommentsByParent.mock.t.Fatalf("RepositoryMock.GetCommentsByParent mock is already set by Expect")
	}

	if mmGetCommentsByParent.defaultExpectation.paramPtrs == nil {
		mmGetCommentsByParent.defaultExpectation.paramPtrs = &RepositoryMockGetCommentsByParentParamPtrs{}
	}
	mmGetCommentsByParent.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetCommentsByParent
}

// ExpectParentIdParam2 sets up expected param parentId for Repository.GetCommentsByParent
func (mmGetCommentsByParent *mRepositoryMockGetCommentsByParent) ExpectParentIdParam2(parentId int) *mRepositoryMockGetCommentsByParent {
	if mmGetCommentsByParent.mock.funcGetCommentsByParent != nil {
		mmGetCommentsByParent.mock.t.Fatalf("RepositoryMock.GetCommentsByParent mock is already set by Set")
	}

	if mmGetCommentsByParent.defaultExpectation == nil {
		mmGetCommentsByParent.defaultExpectation = &RepositoryMockGetCommentsByParentExpectation{}
	}

	if mmGetCommentsByParent.defaultExpectation.params != nil {
		mmGetCommentsByParent.mock.t.Fatalf("RepositoryMock.GetCommentsByParent mock is already set by Expect")
	}

	if mmGetCommentsByParent.defaultExpectation.paramPtrs == nil {
		mmGetCommentsByParent.defaultExpectation.paramPtrs = &RepositoryMockGetCommentsByParentParamPtrs{}
	}
	mmGetCommentsByParent.defaultExpectation.paramPtrs.parentId = &parentId

	return mmGetCommentsByParent
}

// ExpectLimitParam3 sets up expected param limit for Repository.GetCommentsByParent
func (mmGetCommentsByParent *mRepositoryMockGetCommentsByParent) ExpectLimitParam3(limit int) *mRepositoryMockGetCommentsByParent {
	if mmGetCommentsByParent.mock.funcGetCommentsByParent != nil {
		mmGetCommentsByParent.mock.t.Fatalf("RepositoryMock.GetCommentsByParent mock is already set by Set")
	}

	if mmGetCommentsByParent.defaultExpectation == nil {
		mmGetCommentsByParent.defaultExpectation = &RepositoryMockGetCommentsByParentExpectation{}
	}

	if mmGetCommentsByParent.defaultExpectation.params != nil {
		mmGetCommentsByParent.mock.t.Fatalf("RepositoryMock.GetCommentsByParent mock is already set by Expect")
	}

	if mmGetCommentsByParent.defaultExpectation.paramPtrs == nil {
		mmGetCommentsByParent.defaultExpectation.paramPtrs = &RepositoryMockGetCommentsByParentParamPtrs{}
	}
	mmGetCommentsByParent.defaultExpectation.paramPtrs.limit = &limit

	return mmGetCommentsByParent
}

// ExpectOffsetParam4 sets up expected param offset for Repository.GetCommentsByParent
func (mmGetCommentsByParent *mRepositoryMockGetCommentsByParent) ExpectOffsetParam4(offset int) *mRepositoryMockGetCommentsByParent {
	if mmGetCommentsByParent.mock.funcGetCommentsByParent != nil {
		mmGetCommentsByParent.mock.t.Fatalf("RepositoryMock.GetCommentsByParent mock is already set by Set")
	}

	if mmGetCommentsByParent.defaultExpectation == nil {
		mmGetCommentsByParent.defaultExpectation = &RepositoryMockGetCommentsByParentExpectation{}
	}

	if mmGetCommentsByParent.defaultExpectation.params != nil {
		mmGetCommentsByParent.mock.t.Fatalf("RepositoryMock.GetCommentsByParent mock is already set by Expect")
	}

	if mmGetCommentsByParent.defaultExpectation.paramPtrs == nil {
		mmGetCommentsByParent.defaultExpectation.paramPtrs = &RepositoryMockGetCommentsByParentParamPtrs{}
	}
	mmGetCommentsByParent.defaultExpectation.paramPtrs.offset = &offset

	return mmGetCommentsByParent
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetCommentsByParent
func (mmGetCommentsByParent *mRepositoryMockGetCommentsByParent) Inspect(f func(ctx context.Context, parentId int, limit int, offset int)) *mRepositoryMockGetCommentsByParent {
	if mmGetCommentsByParent.mock.inspectFuncGetCommentsByParent != nil {
		mmGetCommentsByParent.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetCommentsByParent")
	}

	mmGetCommentsByParent.mock.inspectFuncGetCommentsByParent = f

	return mmGetCommentsByParent
}

// Return sets up results that will be returned by Repository.GetCommentsByParent
func (mmGetCommentsByParent *mRepositoryMockGetCommentsByParent) Return(cpa1 []*domain.Comment, err error) *RepositoryMock {
	if mmGetCommentsByParent.mock.funcGetCommentsByParent != nil {
		mmGetCommentsByParent.mock.t.Fatalf("RepositoryMock.GetCommentsByParent mock is already set by Set")
	}

	if mmGetCommentsByParent.defaultExpectation == nil {
		mmGetCommentsByParent.defaultExpectation = &RepositoryMockGetCommentsByParentExpectation{mock: mmGetCommentsByParent.mock}
	}
	mmGetCommentsByParent.defaultExpectation.results = &RepositoryMockGetCommentsByParentResults{cpa1, err}
	return mmGetCommentsByParent.mock
}

// Set uses given function f to mock the Repository.GetCommentsByParent method
func (mmGetCommentsByParent *mRepositoryMockGetCommentsByParent) Set(f func(ctx context.Context, parentId int, limit int, offset int) (cpa1 []*domain.Comment, err error)) *RepositoryMock {
	if mmGetCommentsByParent.defaultExpectation != nil {
		mmGetCommentsByParent.mock.t.Fatalf("Default expectation is already set for the Repository.GetCommentsByParent method")
	}

	if len(mmGetCommentsByParent.expectations) > 0 {
		mmGetCommentsByParent.mock.t.Fatalf("Some expectations are already set for the Repository.GetCommentsByParent method")
	}

	mmGetCommentsByParent.mock.funcGetCommentsByParent = f
	return mmGetCommentsByParent.mock
}

// When sets expectation for the Repository.GetCommentsByParent which will trigger the result defined by the following
// Then helper
func (mmGetCommentsByParent *mRepositoryMockGetCommentsByParent) When(ctx context.Context, parentId int, limit int, offset int) *RepositoryMockGetCommentsByParentExpectation {
	if mmGetCommentsByParent.mock.funcGetCommentsByParent != nil {
		mmGetCommentsByParent.mock.t.Fatalf("RepositoryMock.GetCommentsByParent mock is already set by Set")
	}

	expectation := &RepositoryMockGetCommentsByParentExpectation{
		mock:   mmGetCommentsByParent.mock,
		params: &RepositoryMockGetCommentsByParentParams{ctx, parentId, limit, offset},
	}
	mmGetCommentsByParent.expectations = append(mmGetCommentsByParent.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetCommentsByParent return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetCommentsByParentExpectation) Then(cpa1 []*domain.Comment, err error) *RepositoryMock {
	e.results = &RepositoryMockGetCommentsByParentResults{cpa1, err}
	return e.mock
}

// Times sets number of times Repository.GetCommentsByParent should be invoked
func (mmGetCommentsByParent *mRepositoryMockGetCommentsByParent) Times(n uint64) *mRepositoryMockGetCommentsByParent {
	if n == 0 {
		mmGetCommentsByParent.mock.t.Fatalf("Times of RepositoryMock.GetCommentsByParent mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetCommentsByParent.expectedInvocations, n)
	return mmGetCommentsByParent
}

func (mmGetCommentsByParent *mRepositoryMockGetCommentsByParent) invocationsDone() bool {
	if len(mmGetCommentsByParent.expectations) == 0 && mmGetCommentsByParent.defaultExpectation == nil && mmGetCommentsByParent.mock.funcGetCommentsByParent == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetCommentsByParent.mock.afterGetCommentsByParentCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetCommentsByParent.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetCommentsByParent implements repository.Repository
func (mmGetCommentsByParent *RepositoryMock) GetCommentsByParent(ctx context.Context, parentId int, limit int, offset int) (cpa1 []*domain.Comment, err error) {
	mm_atomic.AddUint64(&mmGetCommentsByParent.beforeGetCommentsByParentCounter, 1)
	defer mm_atomic.AddUint64(&mmGetCommentsByParent.afterGetCommentsByParentCounter, 1)

	if mmGetCommentsByParent.inspectFuncGetCommentsByParent != nil {
		mmGetCommentsByParent.inspectFuncGetCommentsByParent(ctx, parentId, limit, offset)
	}

	mm_params := RepositoryMockGetCommentsByParentParams{ctx, parentId, limit, offset}

	// Record call args
	mmGetCommentsByParent.GetCommentsByParentMock.mutex.Lock()
	mmGetCommentsByParent.GetCommentsByParentMock.callArgs = append(mmGetCommentsByParent.GetCommentsByParentMock.callArgs, &mm_params)
	mmGetCommentsByParent.GetCommentsByParentMock.mutex.Unlock()

	for _, e := range mmGetCommentsByParent.GetCommentsByParentMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cpa1, e.results.err
		}
	}

	if mmGetCommentsByParent.GetCommentsByParentMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetCommentsByParent.GetCommentsByParentMock.defaultExpectation.Counter, 1)
		mm_want := mmGetCommentsByParent.GetCommentsByParentMock.defaultExpectation.params
		mm_want_ptrs := mmGetCommentsByParent.GetCommentsByParentMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetCommentsByParentParams{ctx, parentId, limit, offset}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetCommentsByParent.t.Errorf("RepositoryMock.GetCommentsByParent got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.parentId != nil && !minimock.Equal(*mm_want_ptrs.parentId, mm_got.parentId) {
				mmGetCommentsByParent.t.Errorf("RepositoryMock.GetCommentsByParent got unexpected parameter parentId, want: %#v, got: %#v%s\n", *mm_want_ptrs.parentId, mm_got.parentId, minimock.Diff(*mm_want_ptrs.parentId, mm_got.parentId))
			}

			if mm_want_ptrs.limit != nil && !minimock.Equal(*mm_want_ptrs.limit, mm_got.limit) {
				mmGetCommentsByParent.t.Errorf("RepositoryMock.GetCommentsByParent got unexpected parameter limit, want: %#v, got: %#v%s\n", *mm_want_ptrs.limit, mm_got.limit, minimock.Diff(*mm_want_ptrs.limit, mm_got.limit))
			}

			if mm_want_ptrs.offset != nil && !minimock.Equal(*mm_want_ptrs.offset, mm_got.offset) {
				mmGetCommentsByParent.t.Errorf("RepositoryMock.GetCommentsByParent got unexpected parameter offset, want: %#v, got: %#v%s\n", *mm_want_ptrs.offset, mm_got.offset, minimock.Diff(*mm_want_ptrs.offset, mm_got.offset))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetCommentsByParent.t.Errorf("RepositoryMock.GetCommentsByParent got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetCommentsByParent.GetCommentsByParentMock.defaultExpectation.results
		if mm_results == nil {
			mmGetCommentsByParent.t.Fatal("No results are set for the RepositoryMock.GetCommentsByParent")
		}
		return (*mm_results).cpa1, (*mm_results).err
	}
	if mmGetCommentsByParent.funcGetCommentsByParent != nil {
		return mmGetCommentsByParent.funcGetCommentsByParent(ctx, parentId, limit, offset)
	}
	mmGetCommentsByParent.t.Fatalf("Unexpected call to RepositoryMock.GetCommentsByParent. %v %v %v %v", ctx, parentId, limit, offset)
	return
}

// GetCommentsByParentAfterCounter returns a count of finished RepositoryMock.GetCommentsByParent invocations
func (mmGetCommentsByParent *RepositoryMock) GetCommentsByParentAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCommentsByParent.afterGetCommentsByParentCounter)
}

// GetCommentsByParentBeforeCounter returns a count of RepositoryMock.GetCommentsByParent invocations
func (mmGetCommentsByParent *RepositoryMock) GetCommentsByParentBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCommentsByParent.beforeGetCommentsByParentCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetCommentsByParent.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetCommentsByParent *mRepositoryMockGetCommentsByParent) Calls() []*RepositoryMockGetCommentsByParentParams {
	mmGetCommentsByParent.mutex.RLock()

	argCopy := make([]*RepositoryMockGetCommentsByParentParams, len(mmGetCommentsByParent.callArgs))
	copy(argCopy, mmGetCommentsByParent.callArgs)

	mmGetCommentsByParent.mutex.RUnlock()

	return argCopy
}

// MinimockGetCommentsByParentDone returns true if the count of the GetCommentsByParent invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetCommentsByParentDone() bool {
	for _, e := range m.GetCommentsByParentMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetCommentsByParentMock.invocationsDone()
}

// MinimockGetCommentsByParentInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetCommentsByParentInspect() {
	for _, e := range m.GetCommentsByParentMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetCommentsByParent with params: %#v", *e.params)
		}
	}

	afterGetCommentsByParentCounter := mm_atomic.LoadUint64(&m.afterGetCommentsByParentCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetCommentsByParentMock.defaultExpectation != nil && afterGetCommentsByParentCounter < 1 {
		if m.GetCommentsByParentMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.GetCommentsByParent")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetCommentsByParent with params: %#v", *m.GetCommentsByParentMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetCommentsByParent != nil && afterGetCommentsByParentCounter < 1 {
		m.t.Error("Expected call to RepositoryMock.GetCommentsByParent")
	}

	if !m.GetCommentsByParentMock.invocationsDone() && afterGetCommentsByParentCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetCommentsByParent but found %d calls",
			mm_atomic.LoadUint64(&m.GetCommentsByParentMock.expectedInvocations), afterGetCommentsByParentCounter)
	}
}

type mRepositoryMockGetCommentsByPost struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetCommentsByPostExpectation
	expectations       []*RepositoryMockGetCommentsByPostExpectation

	callArgs []*RepositoryMockGetCommentsByPostParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryMockGetCommentsByPostExpectation specifies expectation struct of the Repository.GetCommentsByPost
type RepositoryMockGetCommentsByPostExpectation struct {
	mock      *RepositoryMock
	params    *RepositoryMockGetCommentsByPostParams
	paramPtrs *RepositoryMockGetCommentsByPostParamPtrs
	results   *RepositoryMockGetCommentsByPostResults
	Counter   uint64
}

// RepositoryMockGetCommentsByPostParams contains parameters of the Repository.GetCommentsByPost
type RepositoryMockGetCommentsByPostParams struct {
	ctx    context.Context
	postID int
	limit  int
	offset int
}

// RepositoryMockGetCommentsByPostParamPtrs contains pointers to parameters of the Repository.GetCommentsByPost
type RepositoryMockGetCommentsByPostParamPtrs struct {
	ctx    *context.Context
	postID *int
	limit  *int
	offset *int
}

// RepositoryMockGetCommentsByPostResults contains results of the Repository.GetCommentsByPost
type RepositoryMockGetCommentsByPostResults struct {
	cpa1 []*domain.Comment
	err  error
}

// Expect sets up expected params for Repository.GetCommentsByPost
func (mmGetCommentsByPost *mRepositoryMockGetCommentsByPost) Expect(ctx context.Context, postID int, limit int, offset int) *mRepositoryMockGetCommentsByPost {
	if mmGetCommentsByPost.mock.funcGetCommentsByPost != nil {
		mmGetCommentsByPost.mock.t.Fatalf("RepositoryMock.GetCommentsByPost mock is already set by Set")
	}

	if mmGetCommentsByPost.defaultExpectation == nil {
		mmGetCommentsByPost.defaultExpectation = &RepositoryMockGetCommentsByPostExpectation{}
	}

	if mmGetCommentsByPost.defaultExpectation.paramPtrs != nil {
		mmGetCommentsByPost.mock.t.Fatalf("RepositoryMock.GetCommentsByPost mock is already set by ExpectParams functions")
	}

	mmGetCommentsByPost.defaultExpectation.params = &RepositoryMockGetCommentsByPostParams{ctx, postID, limit, offset}
	for _, e := range mmGetCommentsByPost.expectations {
		if minimock.Equal(e.params, mmGetCommentsByPost.defaultExpectation.params) {
			mmGetCommentsByPost.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetCommentsByPost.defaultExpectation.params)
		}
	}

	return mmGetCommentsByPost
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetCommentsByPost
func (mmGetCommentsByPost *mRepositoryMockGetCommentsByPost) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetCommentsByPost {
	if mmGetCommentsByPost.mock.funcGetCommentsByPost != nil {
		mmGetCommentsByPost.mock.t.Fatalf("RepositoryMock.GetCommentsByPost mock is already set by Set")
	}

	if mmGetCommentsByPost.defaultExpectation == nil {
		mmGetCommentsByPost.defaultExpectation = &RepositoryMockGetCommentsByPostExpectation{}
	}

	if mmGetCommentsByPost.defaultExpectation.params != nil {
		mmGetCommentsByPost.mock.t.Fatalf("RepositoryMock.GetCommentsByPost mock is already set by Expect")
	}

	if mmGetCommentsByPost.defaultExpectation.paramPtrs == nil {
		mmGetCommentsByPost.defaultExpectation.paramPtrs = &RepositoryMockGetCommentsByPostParamPtrs{}
	}
	mmGetCommentsByPost.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetCommentsByPost
}

// ExpectPostIDParam2 sets up expected param postID for Repository.GetCommentsByPost
func (mmGetCommentsByPost *mRepositoryMockGetCommentsByPost) ExpectPostIDParam2(postID int) *mRepositoryMockGetCommentsByPost {
	if mmGetCommentsByPost.mock.funcGetCommentsByPost != nil {
		mmGetCommentsByPost.mock.t.Fatalf("RepositoryMock.GetCommentsByPost mock is already set by Set")
	}

	if mmGetCommentsByPost.defaultExpectation == nil {
		mmGetCommentsByPost.defaultExpectation = &RepositoryMockGetCommentsByPostExpectation{}
	}

	if mmGetCommentsByPost.defaultExpectation.params != nil {
		mmGetCommentsByPost.mock.t.Fatalf("RepositoryMock.GetCommentsByPost mock is already set by Expect")
	}

	if mmGetCommentsByPost.defaultExpectation.paramPtrs == nil {
		mmGetCommentsByPost.defaultExpectation.paramPtrs = &RepositoryMockGetCommentsByPostParamPtrs{}
	}
	mmGetCommentsByPost.defaultExpectation.paramPtrs.postID = &postID

	return mmGetCommentsByPost
}

// ExpectLimitParam3 sets up expected param limit for Repository.GetCommentsByPost
func (mmGetCommentsByPost *mRepositoryMockGetCommentsByPost) ExpectLimitParam3(limit int) *mRepositoryMockGetCommentsByPost {
	if mmGetCommentsByPost.mock.funcGetCommentsByPost != nil {
		mmGetCommentsByPost.mock.t.Fatalf("RepositoryMock.GetCommentsByPost mock is already set by Set")
	}

	if mmGetCommentsByPost.defaultExpectation == nil {
		mmGetCommentsByPost.defaultExpectation = &RepositoryMockGetCommentsByPostExpectation{}
	}

	if mmGetCommentsByPost.defaultExpectation.params != nil {
		mmGetCommentsByPost.mock.t.Fatalf("RepositoryMock.GetCommentsByPost mock is already set by Expect")
	}

	if mmGetCommentsByPost.defaultExpectation.paramPtrs == nil {
		mmGetCommentsByPost.defaultExpectation.paramPtrs = &RepositoryMockGetCommentsByPostParamPtrs{}
	}
	mmGetCommentsByPost.defaultExpectation.paramPtrs.limit = &limit

	return mmGetCommentsByPost
}

// ExpectOffsetParam4 sets up expected param offset for Repository.GetCommentsByPost
func (mmGetCommentsByPost *mRepositoryMockGetCommentsByPost) ExpectOffsetParam4(offset int) *mRepositoryMockGetCommentsByPost {
	if mmGetCommentsByPost.mock.funcGetCommentsByPost != nil {
		mmGetCommentsByPost.mock.t.Fatalf("RepositoryMock.GetCommentsByPost mock is already set by Set")
	}

	if mmGetCommentsByPost.defaultExpectation == nil {
		mmGetCommentsByPost.defaultExpectation = &RepositoryMockGetCommentsByPostExpectation{}
	}

	if mmGetCommentsByPost.defaultExpectation.params != nil {
		mmGetCommentsByPost.mock.t.Fatalf("RepositoryMock.GetCommentsByPost mock is already set by Expect")
	}

	if mmGetCommentsByPost.defaultExpectation.paramPtrs == nil {
		mmGetCommentsByPost.defaultExpectation.paramPtrs = &RepositoryMockGetCommentsByPostParamPtrs{}
	}
	mmGetCommentsByPost.defaultExpectation.paramPtrs.offset = &offset

	return mmGetCommentsByPost
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetCommentsByPost
func (mmGetCommentsByPost *mRepositoryMockGetCommentsByPost) Inspect(f func(ctx context.Context, postID int, limit int, offset int)) *mRepositoryMockGetCommentsByPost {
	if mmGetCommentsByPost.mock.inspectFuncGetCommentsByPost != nil {
		mmGetCommentsByPost.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetCommentsByPost")
	}

	mmGetCommentsByPost.mock.inspectFuncGetCommentsByPost = f

	return mmGetCommentsByPost
}

// Return sets up results that will be returned by Repository.GetCommentsByPost
func (mmGetCommentsByPost *mRepositoryMockGetCommentsByPost) Return(cpa1 []*domain.Comment, err error) *RepositoryMock {
	if mmGetCommentsByPost.mock.funcGetCommentsByPost != nil {
		mmGetCommentsByPost.mock.t.Fatalf("RepositoryMock.GetCommentsByPost mock is already set by Set")
	}

	if mmGetCommentsByPost.defaultExpectation == nil {
		mmGetCommentsByPost.defaultExpectation = &RepositoryMockGetCommentsByPostExpectation{mock: mmGetCommentsByPost.mock}
	}
	mmGetCommentsByPost.defaultExpectation.results = &RepositoryMockGetCommentsByPostResults{cpa1, err}
	return mmGetCommentsByPost.mock
}

// Set uses given function f to mock the Repository.GetCommentsByPost method
func (mmGetCommentsByPost *mRepositoryMockGetCommentsByPost) Set(f func(ctx context.Context, postID int, limit int, offset int) (cpa1 []*domain.Comment, err error)) *RepositoryMock {
	if mmGetCommentsByPost.defaultExpectation != nil {
		mmGetCommentsByPost.mock.t.Fatalf("Default expectation is already set for the Repository.GetCommentsByPost method")
	}

	if len(mmGetCommentsByPost.expectations) > 0 {
		mmGetCommentsByPost.mock.t.Fatalf("Some expectations are already set for the Repository.GetCommentsByPost method")
	}

	mmGetCommentsByPost.mock.funcGetCommentsByPost = f
	return mmGetCommentsByPost.mock
}

// When sets expectation for the Repository.GetCommentsByPost which will trigger the result defined by the following
// Then helper
func (mmGetCommentsByPost *mRepositoryMockGetCommentsByPost) When(ctx context.Context, postID int, limit int, offset int) *RepositoryMockGetCommentsByPostExpectation {
	if mmGetCommentsByPost.mock.funcGetCommentsByPost != nil {
		mmGetCommentsByPost.mock.t.Fatalf("RepositoryMock.GetCommentsByPost mock is already set by Set")
	}

	expectation := &RepositoryMockGetCommentsByPostExpectation{
		mock:   mmGetCommentsByPost.mock,
		params: &RepositoryMockGetCommentsByPostParams{ctx, postID, limit, offset},
	}
	mmGetCommentsByPost.expectations = append(mmGetCommentsByPost.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetCommentsByPost return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetCommentsByPostExpectation) Then(cpa1 []*domain.Comment, err error) *RepositoryMock {
	e.results = &RepositoryMockGetCommentsByPostResults{cpa1, err}
	return e.mock
}

// Times sets number of times Repository.GetCommentsByPost should be invoked
func (mmGetCommentsByPost *mRepositoryMockGetCommentsByPost) Times(n uint64) *mRepositoryMockGetCommentsByPost {
	if n == 0 {
		mmGetCommentsByPost.mock.t.Fatalf("Times of RepositoryMock.GetCommentsByPost mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetCommentsByPost.expectedInvocations, n)
	return mmGetCommentsByPost
}

func (mmGetCommentsByPost *mRepositoryMockGetCommentsByPost) invocationsDone() bool {
	if len(mmGetCommentsByPost.expectations) == 0 && mmGetCommentsByPost.defaultExpectation == nil && mmGetCommentsByPost.mock.funcGetCommentsByPost == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetCommentsByPost.mock.afterGetCommentsByPostCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetCommentsByPost.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetCommentsByPost implements repository.Repository
func (mmGetCommentsByPost *RepositoryMock) GetCommentsByPost(ctx context.Context, postID int, limit int, offset int) (cpa1 []*domain.Comment, err error) {
	mm_atomic.AddUint64(&mmGetCommentsByPost.beforeGetCommentsByPostCounter, 1)
	defer mm_atomic.AddUint64(&mmGetCommentsByPost.afterGetCommentsByPostCounter, 1)

	if mmGetCommentsByPost.inspectFuncGetCommentsByPost != nil {
		mmGetCommentsByPost.inspectFuncGetCommentsByPost(ctx, postID, limit, offset)
	}

	mm_params := RepositoryMockGetCommentsByPostParams{ctx, postID, limit, offset}

	// Record call args
	mmGetCommentsByPost.GetCommentsByPostMock.mutex.Lock()
	mmGetCommentsByPost.GetCommentsByPostMock.callArgs = append(mmGetCommentsByPost.GetCommentsByPostMock.callArgs, &mm_params)
	mmGetCommentsByPost.GetCommentsByPostMock.mutex.Unlock()

	for _, e := range mmGetCommentsByPost.GetCommentsByPostMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cpa1, e.results.err
		}
	}

	if mmGetCommentsByPost.GetCommentsByPostMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetCommentsByPost.GetCommentsByPostMock.defaultExpectation.Counter, 1)
		mm_want := mmGetCommentsByPost.GetCommentsByPostMock.defaultExpectation.params
		mm_want_ptrs := mmGetCommentsByPost.GetCommentsByPostMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetCommentsByPostParams{ctx, postID, limit, offset}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetCommentsByPost.t.Errorf("RepositoryMock.GetCommentsByPost got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.postID != nil && !minimock.Equal(*mm_want_ptrs.postID, mm_got.postID) {
				mmGetCommentsByPost.t.Errorf("RepositoryMock.GetCommentsByPost got unexpected parameter postID, want: %#v, got: %#v%s\n", *mm_want_ptrs.postID, mm_got.postID, minimock.Diff(*mm_want_ptrs.postID, mm_got.postID))
			}

			if mm_want_ptrs.limit != nil && !minimock.Equal(*mm_want_ptrs.limit, mm_got.limit) {
				mmGetCommentsByPost.t.Errorf("RepositoryMock.GetCommentsByPost got unexpected parameter limit, want: %#v, got: %#v%s\n", *mm_want_ptrs.limit, mm_got.limit, minimock.Diff(*mm_want_ptrs.limit, mm_got.limit))
			}

			if mm_want_ptrs.offset != nil && !minimock.Equal(*mm_want_ptrs.offset, mm_got.offset) {
				mmGetCommentsByPost.t.Errorf("RepositoryMock.GetCommentsByPost got unexpected parameter offset, want: %#v, got: %#v%s\n", *mm_want_ptrs.offset, mm_got.offset, minimock.Diff(*mm_want_ptrs.offset, mm_got.offset))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetCommentsByPost.t.Errorf("RepositoryMock.GetCommentsByPost got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetCommentsByPost.GetCommentsByPostMock.defaultExpectation.results
		if mm_results == nil {
			mmGetCommentsByPost.t.Fatal("No results are set for the RepositoryMock.GetCommentsByPost")
		}
		return (*mm_results).cpa1, (*mm_results).err
	}
	if mmGetCommentsByPost.funcGetCommentsByPost != nil {
		return mmGetCommentsByPost.funcGetCommentsByPost(ctx, postID, limit, offset)
	}
	mmGetCommentsByPost.t.Fatalf("Unexpected call to RepositoryMock.GetCommentsByPost. %v %v %v %v", ctx, postID, limit, offset)
	return
}

// GetCommentsByPostAfterCounter returns a count of finished RepositoryMock.GetCommentsByPost invocations
func (mmGetCommentsByPost *RepositoryMock) GetCommentsByPostAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCommentsByPost.afterGetCommentsByPostCounter)
}

// GetCommentsByPostBeforeCounter returns a count of RepositoryMock.GetCommentsByPost invocations
func (mmGetCommentsByPost *RepositoryMock) GetCommentsByPostBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCommentsByPost.beforeGetCommentsByPostCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetCommentsByPost.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetCommentsByPost *mRepositoryMockGetCommentsByPost) Calls() []*RepositoryMockGetCommentsByPostParams {
	mmGetCommentsByPost.mutex.RLock()

	argCopy := make([]*RepositoryMockGetCommentsByPostParams, len(mmGetCommentsByPost.callArgs))
	copy(argCopy, mmGetCommentsByPost.callArgs)

	mmGetCommentsByPost.mutex.RUnlock()

	return argCopy
}

// MinimockGetCommentsByPostDone returns true if the count of the GetCommentsByPost invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetCommentsByPostDone() bool {
	for _, e := range m.GetCommentsByPostMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetCommentsByPostMock.invocationsDone()
}

// MinimockGetCommentsByPostInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetCommentsByPostInspect() {
	for _, e := range m.GetCommentsByPostMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetCommentsByPost with params: %#v", *e.params)
		}
	}

	afterGetCommentsByPostCounter := mm_atomic.LoadUint64(&m.afterGetCommentsByPostCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetCommentsByPostMock.defaultExpectation != nil && afterGetCommentsByPostCounter < 1 {
		if m.GetCommentsByPostMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.GetCommentsByPost")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetCommentsByPost with params: %#v", *m.GetCommentsByPostMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetCommentsByPost != nil && afterGetCommentsByPostCounter < 1 {
		m.t.Error("Expected call to RepositoryMock.GetCommentsByPost")
	}

	if !m.GetCommentsByPostMock.invocationsDone() && afterGetCommentsByPostCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetCommentsByPost but found %d calls",
			mm_atomic.LoadUint64(&m.GetCommentsByPostMock.expectedInvocations), afterGetCommentsByPostCounter)
	}
}

type mRepositoryMockGetPost struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetPostExpectation
	expectations       []*RepositoryMockGetPostExpectation

	callArgs []*RepositoryMockGetPostParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryMockGetPostExpectation specifies expectation struct of the Repository.GetPost
type RepositoryMockGetPostExpectation struct {
	mock      *RepositoryMock
	params    *RepositoryMockGetPostParams
	paramPtrs *RepositoryMockGetPostParamPtrs
	results   *RepositoryMockGetPostResults
	Counter   uint64
}

// RepositoryMockGetPostParams contains parameters of the Repository.GetPost
type RepositoryMockGetPostParams struct {
	ctx context.Context
	id  int
}

// RepositoryMockGetPostParamPtrs contains pointers to parameters of the Repository.GetPost
type RepositoryMockGetPostParamPtrs struct {
	ctx *context.Context
	id  *int
}

// RepositoryMockGetPostResults contains results of the Repository.GetPost
type RepositoryMockGetPostResults struct {
	pp1 *domain.Post
	err error
}

// Expect sets up expected params for Repository.GetPost
func (mmGetPost *mRepositoryMockGetPost) Expect(ctx context.Context, id int) *mRepositoryMockGetPost {
	if mmGetPost.mock.funcGetPost != nil {
		mmGetPost.mock.t.Fatalf("RepositoryMock.GetPost mock is already set by Set")
	}

	if mmGetPost.defaultExpectation == nil {
		mmGetPost.defaultExpectation = &RepositoryMockGetPostExpectation{}
	}

	if mmGetPost.defaultExpectation.paramPtrs != nil {
		mmGetPost.mock.t.Fatalf("RepositoryMock.GetPost mock is already set by ExpectParams functions")
	}

	mmGetPost.defaultExpectation.params = &RepositoryMockGetPostParams{ctx, id}
	for _, e := range mmGetPost.expectations {
		if minimock.Equal(e.params, mmGetPost.defaultExpectation.params) {
			mmGetPost.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetPost.defaultExpectation.params)
		}
	}

	return mmGetPost
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetPost
func (mmGetPost *mRepositoryMockGetPost) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetPost {
	if mmGetPost.mock.funcGetPost != nil {
		mmGetPost.mock.t.Fatalf("RepositoryMock.GetPost mock is already set by Set")
	}

	if mmGetPost.defaultExpectation == nil {
		mmGetPost.defaultExpectation = &RepositoryMockGetPostExpectation{}
	}

	if mmGetPost.defaultExpectation.params != nil {
		mmGetPost.mock.t.Fatalf("RepositoryMock.GetPost mock is already set by Expect")
	}

	if mmGetPost.defaultExpectation.paramPtrs == nil {
		mmGetPost.defaultExpectation.paramPtrs = &RepositoryMockGetPostParamPtrs{}
	}
	mmGetPost.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetPost
}

// ExpectIdParam2 sets up expected param id for Repository.GetPost
func (mmGetPost *mRepositoryMockGetPost) ExpectIdParam2(id int) *mRepositoryMockGetPost {
	if mmGetPost.mock.funcGetPost != nil {
		mmGetPost.mock.t.Fatalf("RepositoryMock.GetPost mock is already set by Set")
	}

	if mmGetPost.defaultExpectation == nil {
		mmGetPost.defaultExpectation = &RepositoryMockGetPostExpectation{}
	}

	if mmGetPost.defaultExpectation.params != nil {
		mmGetPost.mock.t.Fatalf("RepositoryMock.GetPost mock is already set by Expect")
	}

	if mmGetPost.defaultExpectation.paramPtrs == nil {
		mmGetPost.defaultExpectation.paramPtrs = &RepositoryMockGetPostParamPtrs{}
	}
	mmGetPost.defaultExpectation.paramPtrs.id = &id

	return mmGetPost
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetPost
func (mmGetPost *mRepositoryMockGetPost) Inspect(f func(ctx context.Context, id int)) *mRepositoryMockGetPost {
	if mmGetPost.mock.inspectFuncGetPost != nil {
		mmGetPost.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetPost")
	}

	mmGetPost.mock.inspectFuncGetPost = f

	return mmGetPost
}

// Return sets up results that will be returned by Repository.GetPost
func (mmGetPost *mRepositoryMockGetPost) Return(pp1 *domain.Post, err error) *RepositoryMock {
	if mmGetPost.mock.funcGetPost != nil {
		mmGetPost.mock.t.Fatalf("RepositoryMock.GetPost mock is already set by Set")
	}

	if mmGetPost.defaultExpectation == nil {
		mmGetPost.defaultExpectation = &RepositoryMockGetPostExpectation{mock: mmGetPost.mock}
	}
	mmGetPost.defaultExpectation.results = &RepositoryMockGetPostResults{pp1, err}
	return mmGetPost.mock
}

// Set uses given function f to mock the Repository.GetPost method
func (mmGetPost *mRepositoryMockGetPost) Set(f func(ctx context.Context, id int) (pp1 *domain.Post, err error)) *RepositoryMock {
	if mmGetPost.defaultExpectation != nil {
		mmGetPost.mock.t.Fatalf("Default expectation is already set for the Repository.GetPost method")
	}

	if len(mmGetPost.expectations) > 0 {
		mmGetPost.mock.t.Fatalf("Some expectations are already set for the Repository.GetPost method")
	}

	mmGetPost.mock.funcGetPost = f
	return mmGetPost.mock
}

// When sets expectation for the Repository.GetPost which will trigger the result defined by the following
// Then helper
func (mmGetPost *mRepositoryMockGetPost) When(ctx context.Context, id int) *RepositoryMockGetPostExpectation {
	if mmGetPost.mock.funcGetPost != nil {
		mmGetPost.mock.t.Fatalf("RepositoryMock.GetPost mock is already set by Set")
	}

	expectation := &RepositoryMockGetPostExpectation{
		mock:   mmGetPost.mock,
		params: &RepositoryMockGetPostParams{ctx, id},
	}
	mmGetPost.expectations = append(mmGetPost.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetPost return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetPostExpectation) Then(pp1 *domain.Post, err error) *RepositoryMock {
	e.results = &RepositoryMockGetPostResults{pp1, err}
	return e.mock
}

// Times sets number of times Repository.GetPost should be invoked
func (mmGetPost *mRepositoryMockGetPost) Times(n uint64) *mRepositoryMockGetPost {
	if n == 0 {
		mmGetPost.mock.t.Fatalf("Times of RepositoryMock.GetPost mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetPost.expectedInvocations, n)
	return mmGetPost
}

func (mmGetPost *mRepositoryMockGetPost) invocationsDone() bool {
	if len(mmGetPost.expectations) == 0 && mmGetPost.defaultExpectation == nil && mmGetPost.mock.funcGetPost == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetPost.mock.afterGetPostCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetPost.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetPost implements repository.Repository
func (mmGetPost *RepositoryMock) GetPost(ctx context.Context, id int) (pp1 *domain.Post, err error) {
	mm_atomic.AddUint64(&mmGetPost.beforeGetPostCounter, 1)
	defer mm_atomic.AddUint64(&mmGetPost.afterGetPostCounter, 1)

	if mmGetPost.inspectFuncGetPost != nil {
		mmGetPost.inspectFuncGetPost(ctx, id)
	}

	mm_params := RepositoryMockGetPostParams{ctx, id}

	// Record call args
	mmGetPost.GetPostMock.mutex.Lock()
	mmGetPost.GetPostMock.callArgs = append(mmGetPost.GetPostMock.callArgs, &mm_params)
	mmGetPost.GetPostMock.mutex.Unlock()

	for _, e := range mmGetPost.GetPostMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp1, e.results.err
		}
	}

	if mmGetPost.GetPostMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetPost.GetPostMock.defaultExpectation.Counter, 1)
		mm_want := mmGetPost.GetPostMock.defaultExpectation.params
		mm_want_ptrs := mmGetPost.GetPostMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetPostParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetPost.t.Errorf("RepositoryMock.GetPost got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmGetPost.t.Errorf("RepositoryMock.GetPost got unexpected parameter id, want: %#v, got: %#v%s\n", *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetPost.t.Errorf("RepositoryMock.GetPost got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetPost.GetPostMock.defaultExpectation.results
		if mm_results == nil {
			mmGetPost.t.Fatal("No results are set for the RepositoryMock.GetPost")
		}
		return (*mm_results).pp1, (*mm_results).err
	}
	if mmGetPost.funcGetPost != nil {
		return mmGetPost.funcGetPost(ctx, id)
	}
	mmGetPost.t.Fatalf("Unexpected call to RepositoryMock.GetPost. %v %v", ctx, id)
	return
}

// GetPostAfterCounter returns a count of finished RepositoryMock.GetPost invocations
func (mmGetPost *RepositoryMock) GetPostAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPost.afterGetPostCounter)
}

// GetPostBeforeCounter returns a count of RepositoryMock.GetPost invocations
func (mmGetPost *RepositoryMock) GetPostBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPost.beforeGetPostCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetPost.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetPost *mRepositoryMockGetPost) Calls() []*RepositoryMockGetPostParams {
	mmGetPost.mutex.RLock()

	argCopy := make([]*RepositoryMockGetPostParams, len(mmGetPost.callArgs))
	copy(argCopy, mmGetPost.callArgs)

	mmGetPost.mutex.RUnlock()

	return argCopy
}

// MinimockGetPostDone returns true if the count of the GetPost invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetPostDone() bool {
	for _, e := range m.GetPostMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetPostMock.invocationsDone()
}

// MinimockGetPostInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetPostInspect() {
	for _, e := range m.GetPostMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetPost with params: %#v", *e.params)
		}
	}

	afterGetPostCounter := mm_atomic.LoadUint64(&m.afterGetPostCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetPostMock.defaultExpectation != nil && afterGetPostCounter < 1 {
		if m.GetPostMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.GetPost")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetPost with params: %#v", *m.GetPostMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPost != nil && afterGetPostCounter < 1 {
		m.t.Error("Expected call to RepositoryMock.GetPost")
	}

	if !m.GetPostMock.invocationsDone() && afterGetPostCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetPost but found %d calls",
			mm_atomic.LoadUint64(&m.GetPostMock.expectedInvocations), afterGetPostCounter)
	}
}

type mRepositoryMockGetPosts struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetPostsExpectation
	expectations       []*RepositoryMockGetPostsExpectation

	callArgs []*RepositoryMockGetPostsParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryMockGetPostsExpectation specifies expectation struct of the Repository.GetPosts
type RepositoryMockGetPostsExpectation struct {
	mock      *RepositoryMock
	params    *RepositoryMockGetPostsParams
	paramPtrs *RepositoryMockGetPostsParamPtrs
	results   *RepositoryMockGetPostsResults
	Counter   uint64
}

// RepositoryMockGetPostsParams contains parameters of the Repository.GetPosts
type RepositoryMockGetPostsParams struct {
	ctx context.Context
}

// RepositoryMockGetPostsParamPtrs contains pointers to parameters of the Repository.GetPosts
type RepositoryMockGetPostsParamPtrs struct {
	ctx *context.Context
}

// RepositoryMockGetPostsResults contains results of the Repository.GetPosts
type RepositoryMockGetPostsResults struct {
	ppa1 []*domain.Post
	err  error
}

// Expect sets up expected params for Repository.GetPosts
func (mmGetPosts *mRepositoryMockGetPosts) Expect(ctx context.Context) *mRepositoryMockGetPosts {
	if mmGetPosts.mock.funcGetPosts != nil {
		mmGetPosts.mock.t.Fatalf("RepositoryMock.GetPosts mock is already set by Set")
	}

	if mmGetPosts.defaultExpectation == nil {
		mmGetPosts.defaultExpectation = &RepositoryMockGetPostsExpectation{}
	}

	if mmGetPosts.defaultExpectation.paramPtrs != nil {
		mmGetPosts.mock.t.Fatalf("RepositoryMock.GetPosts mock is already set by ExpectParams functions")
	}

	mmGetPosts.defaultExpectation.params = &RepositoryMockGetPostsParams{ctx}
	for _, e := range mmGetPosts.expectations {
		if minimock.Equal(e.params, mmGetPosts.defaultExpectation.params) {
			mmGetPosts.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetPosts.defaultExpectation.params)
		}
	}

	return mmGetPosts
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetPosts
func (mmGetPosts *mRepositoryMockGetPosts) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetPosts {
	if mmGetPosts.mock.funcGetPosts != nil {
		mmGetPosts.mock.t.Fatalf("RepositoryMock.GetPosts mock is already set by Set")
	}

	if mmGetPosts.defaultExpectation == nil {
		mmGetPosts.defaultExpectation = &RepositoryMockGetPostsExpectation{}
	}

	if mmGetPosts.defaultExpectation.params != nil {
		mmGetPosts.mock.t.Fatalf("RepositoryMock.GetPosts mock is already set by Expect")
	}

	if mmGetPosts.defaultExpectation.paramPtrs == nil {
		mmGetPosts.defaultExpectation.paramPtrs = &RepositoryMockGetPostsParamPtrs{}
	}
	mmGetPosts.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetPosts
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetPosts
func (mmGetPosts *mRepositoryMockGetPosts) Inspect(f func(ctx context.Context)) *mRepositoryMockGetPosts {
	if mmGetPosts.mock.inspectFuncGetPosts != nil {
		mmGetPosts.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetPosts")
	}

	mmGetPosts.mock.inspectFuncGetPosts = f

	return mmGetPosts
}

// Return sets up results that will be returned by Repository.GetPosts
func (mmGetPosts *mRepositoryMockGetPosts) Return(ppa1 []*domain.Post, err error) *RepositoryMock {
	if mmGetPosts.mock.funcGetPosts != nil {
		mmGetPosts.mock.t.Fatalf("RepositoryMock.GetPosts mock is already set by Set")
	}

	if mmGetPosts.defaultExpectation == nil {
		mmGetPosts.defaultExpectation = &RepositoryMockGetPostsExpectation{mock: mmGetPosts.mock}
	}
	mmGetPosts.defaultExpectation.results = &RepositoryMockGetPostsResults{ppa1, err}
	return mmGetPosts.mock
}

// Set uses given function f to mock the Repository.GetPosts method
func (mmGetPosts *mRepositoryMockGetPosts) Set(f func(ctx context.Context) (ppa1 []*domain.Post, err error)) *RepositoryMock {
	if mmGetPosts.defaultExpectation != nil {
		mmGetPosts.mock.t.Fatalf("Default expectation is already set for the Repository.GetPosts method")
	}

	if len(mmGetPosts.expectations) > 0 {
		mmGetPosts.mock.t.Fatalf("Some expectations are already set for the Repository.GetPosts method")
	}

	mmGetPosts.mock.funcGetPosts = f
	return mmGetPosts.mock
}

// When sets expectation for the Repository.GetPosts which will trigger the result defined by the following
// Then helper
func (mmGetPosts *mRepositoryMockGetPosts) When(ctx context.Context) *RepositoryMockGetPostsExpectation {
	if mmGetPosts.mock.funcGetPosts != nil {
		mmGetPosts.mock.t.Fatalf("RepositoryMock.GetPosts mock is already set by Set")
	}

	expectation := &RepositoryMockGetPostsExpectation{
		mock:   mmGetPosts.mock,
		params: &RepositoryMockGetPostsParams{ctx},
	}
	mmGetPosts.expectations = append(mmGetPosts.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetPosts return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetPostsExpectation) Then(ppa1 []*domain.Post, err error) *RepositoryMock {
	e.results = &RepositoryMockGetPostsResults{ppa1, err}
	return e.mock
}

// Times sets number of times Repository.GetPosts should be invoked
func (mmGetPosts *mRepositoryMockGetPosts) Times(n uint64) *mRepositoryMockGetPosts {
	if n == 0 {
		mmGetPosts.mock.t.Fatalf("Times of RepositoryMock.GetPosts mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetPosts.expectedInvocations, n)
	return mmGetPosts
}

func (mmGetPosts *mRepositoryMockGetPosts) invocationsDone() bool {
	if len(mmGetPosts.expectations) == 0 && mmGetPosts.defaultExpectation == nil && mmGetPosts.mock.funcGetPosts == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetPosts.mock.afterGetPostsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetPosts.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetPosts implements repository.Repository
func (mmGetPosts *RepositoryMock) GetPosts(ctx context.Context) (ppa1 []*domain.Post, err error) {
	mm_atomic.AddUint64(&mmGetPosts.beforeGetPostsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetPosts.afterGetPostsCounter, 1)

	if mmGetPosts.inspectFuncGetPosts != nil {
		mmGetPosts.inspectFuncGetPosts(ctx)
	}

	mm_params := RepositoryMockGetPostsParams{ctx}

	// Record call args
	mmGetPosts.GetPostsMock.mutex.Lock()
	mmGetPosts.GetPostsMock.callArgs = append(mmGetPosts.GetPostsMock.callArgs, &mm_params)
	mmGetPosts.GetPostsMock.mutex.Unlock()

	for _, e := range mmGetPosts.GetPostsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ppa1, e.results.err
		}
	}

	if mmGetPosts.GetPostsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetPosts.GetPostsMock.defaultExpectation.Counter, 1)
		mm_want := mmGetPosts.GetPostsMock.defaultExpectation.params
		mm_want_ptrs := mmGetPosts.GetPostsMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetPostsParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetPosts.t.Errorf("RepositoryMock.GetPosts got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetPosts.t.Errorf("RepositoryMock.GetPosts got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetPosts.GetPostsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetPosts.t.Fatal("No results are set for the RepositoryMock.GetPosts")
		}
		return (*mm_results).ppa1, (*mm_results).err
	}
	if mmGetPosts.funcGetPosts != nil {
		return mmGetPosts.funcGetPosts(ctx)
	}
	mmGetPosts.t.Fatalf("Unexpected call to RepositoryMock.GetPosts. %v", ctx)
	return
}

// GetPostsAfterCounter returns a count of finished RepositoryMock.GetPosts invocations
func (mmGetPosts *RepositoryMock) GetPostsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPosts.afterGetPostsCounter)
}

// GetPostsBeforeCounter returns a count of RepositoryMock.GetPosts invocations
func (mmGetPosts *RepositoryMock) GetPostsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPosts.beforeGetPostsCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetPosts.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetPosts *mRepositoryMockGetPosts) Calls() []*RepositoryMockGetPostsParams {
	mmGetPosts.mutex.RLock()

	argCopy := make([]*RepositoryMockGetPostsParams, len(mmGetPosts.callArgs))
	copy(argCopy, mmGetPosts.callArgs)

	mmGetPosts.mutex.RUnlock()

	return argCopy
}

// MinimockGetPostsDone returns true if the count of the GetPosts invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetPostsDone() bool {
	for _, e := range m.GetPostsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetPostsMock.invocationsDone()
}

// MinimockGetPostsInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetPostsInspect() {
	for _, e := range m.GetPostsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetPosts with params: %#v", *e.params)
		}
	}

	afterGetPostsCounter := mm_atomic.LoadUint64(&m.afterGetPostsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetPostsMock.defaultExpectation != nil && afterGetPostsCounter < 1 {
		if m.GetPostsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.GetPosts")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetPosts with params: %#v", *m.GetPostsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPosts != nil && afterGetPostsCounter < 1 {
		m.t.Error("Expected call to RepositoryMock.GetPosts")
	}

	if !m.GetPostsMock.invocationsDone() && afterGetPostsCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetPosts but found %d calls",
			mm_atomic.LoadUint64(&m.GetPostsMock.expectedInvocations), afterGetPostsCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *RepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockContainsCommentInspect()

			m.MinimockContainsPostInspect()

			m.MinimockCreateCommentInspect()

			m.MinimockCreatePostInspect()

			m.MinimockDisableCommentsInspect()

			m.MinimockGetCommentsByParentInspect()

			m.MinimockGetCommentsByPostInspect()

			m.MinimockGetPostInspect()

			m.MinimockGetPostsInspect()
			m.t.FailNow()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *RepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *RepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockContainsCommentDone() &&
		m.MinimockContainsPostDone() &&
		m.MinimockCreateCommentDone() &&
		m.MinimockCreatePostDone() &&
		m.MinimockDisableCommentsDone() &&
		m.MinimockGetCommentsByParentDone() &&
		m.MinimockGetCommentsByPostDone() &&
		m.MinimockGetPostDone() &&
		m.MinimockGetPostsDone()
}
